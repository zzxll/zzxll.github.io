<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    学习笔记：程序设计实习 第1周 从C走进C++ | zzxll&#39;s blog
</title>
<link rel="shortcut icon" href="https://zzxll.github.io/favicon.ico?v=1624776714041">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://zzxll.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://zzxll.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


        
            
                <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
                <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
                

                    
                            
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://zzxll.github.io">
                <img class="avatar" src="https://zzxll.github.io/images/avatar.png?v=1624776714041" alt="">
            </a>
            <div class="site-title">
                <h1>
                    zzxll&#39;s blog
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-detail main-container">
                <!-- left -->
                <div id="content" class="main-container-left">
                    <article class="post i-card">
                        <h2 class="post-title">
                            学习笔记：程序设计实习 第1周 从C走进C++
                        </h2>
                        <div class="post-info">
                            <time class="post-time">2020-05-12</time>
                            
                                <a href="https://zzxll.github.io/tag/xue-xi-bi-ji/" class="post-tag i-tag
                            i-tag-other_1">
                            #学习笔记
                        </a>
                                
                                <a href="https://zzxll.github.io/tag/c/" class="post-tag i-tag
                            i-tag-success">
                            #C++
                        </a>
                                
                                <a href="https://zzxll.github.io/tag/cheng-xu-she-ji-shi-xi/" class="post-tag i-tag
                            i-tag-">
                            #程序设计实习
                        </a>
                                
                        </div>
                        
                                <div class="post-content">
                                    <p>本文是<a href="https://www.bilibili.com/video/av60329215/">“北京大学—程序设计实习[C++]”</a>公开课的听课笔记，配套教材是任课老师自己编写的<a href="https://book.douban.com/subject/11529009/">《新标准C++程序设计教程》</a>，博主是C++入门菜鸟，故整理并记录在博客里，方便后续查看。</p>
<!-- more -->
<h2 id="函数指针">函数指针</h2>
<p>程序运行期间，每个函数都会占用一段连续的内存空间。函数名就是该函数所占内存区域的起始地址（也称入口地址）。可以将函数的入口地址赋给一个指针变量，使该指针变量指向该函数。通过指针变量调用这个函数，这种指向函数的指针变量称为“函数指针”。</p>
<figure data-type="image" tabindex="1"><img src="https://zzxll.github.io/post-images/1589214091310.png" alt="函数指针示意图" loading="lazy"></figure>
<h3 id="定义形式">定义形式</h3>
<p>类型名（*指针变量名）（参数类型1，参数类型2，...）</p>
<p>例如：<code>int(*pf)(int, char);</code></p>
<p>上面表示pf是一个函数指针，函数指针的返回值和参数类型应与指向函数一致：他所指向的函数的返回值类型应该是int，该函数有两个参数，第一个是int类型，第二个时char类型。</p>
<h3 id="使用方法">使用方法</h3>
<p>可以用一个原型匹配的函数的名字，给一个函数指针赋值，通过函数指针调用它所指向的函数，写法为：</p>
<p>函数指针名（实参表）</p>
<p>例如：<code>pf(x, y);</code></p>
<pre><code class="language-c++"># include &lt;stdio.h&gt;
void PrintMin(int a, int b) {
	if (a &lt; b)
		printf(&quot;%d&quot;, a);
	else
		printf(&quot;%d&quot;, b);
}

int main() {
	void(*pf)(int, int); //定义函数指针
	int x = 4, y = 5;
	pf = PrintMin; //给函数指针赋值
	pf(x, y); //使用函数指针
	return 0;
}
</code></pre>
<h3 id="函数指针和qsort库函数">函数指针和qsort库函数</h3>
<p>C语言快速排序库函数：qsort库函数，可以对任意类型的数组进行排序，定义为：</p>
<pre><code class="language-c++">void qsort(void *base, int nelem, unsigned int width, int(*pfCompare)(const void *,const void *));
</code></pre>
<ol>
<li><code>void *base</code>：数组起始位置</li>
<li><code>int nelem</code>：数组元素的个数</li>
<li><code>unsigned int width</code>：每个元素的大小（由此可以算出每个元素的地址）</li>
<li><code>int(*pfCompare)(const void *,const void *)</code>：元素谁在前谁在后的规则</li>
</ol>
<p>函数指针：pfCompare，它指向一个“比较函数”，该比较函数应为以下形式：</p>
<pre><code class="language-c++">int 函数名(const void *elem1, const void *elem2);
</code></pre>
<p>排序就是一个不断比较并交换位置的过程。</p>
<p>qsort函数在执行时，会通过pfCompare指针调用“比较函数“，调用时将要比较的两个元素的地址传给”比较函数“，然后根据“比较函数”返回值判断两个元素哪个更应该排在前面。</p>
<p>比较函数规则：</p>
<ol>
<li>如果<code>* elem1</code>应该排在<code>* elem2</code>前面，则函数返回值是负整数</li>
<li>如果<code>* elem1</code>和<code>* elem2</code>哪个在前面都可以，则函数返回0</li>
<li>如果<code>* elem1</code>应该排在<code>* elem2</code>后面，则函数返回值是正整数</li>
</ol>
<p>实例1：</p>
<p>下面的程序，功能是调用去sort库函数，将一个<code>unsigned int</code>数组按照个位数从小到大进行排序，比如8，23，15三个数，按个位数从小到大排序，应该是23，15，8；</p>
<p>分析：</p>
<p>需要自己定义一个比较规则，编写比较函数</p>
<pre><code class="language-c++">int myCompare(const void* elem1, const void* elem2)
</code></pre>
<p>其中需要注意的是，<code>* elem1</code>是<code>void *</code>类型的指针，编译器不知道<code>elem1</code>指向的元素是多少字节，所以无法编译。这里加了个<code>(usigned int *)</code>的强制转换。</p>
<p>程序：</p>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int myCompare(const void* elem1, const void* elem2) {
	unsigned int* p1, * p2;
	p1 = (unsigned int*)elem1; //&quot;* elem1&quot;非法
	p2 = (unsigned int*)elem2;
	return (*p1 % 10) - (*p2 % 10);
}

#define NUM 5
int main() {
	unsigned int an[NUM] = { 8,123,11,10,4 };
	qsort(an, NUM, sizeof(unsigned int), myCompare);
	for (int i = 0; i &lt; NUM; i++) {
		printf(&quot;%d &quot;, an[i]);
	}
	return 0;
}//输出结果：10 11 123 4 8
</code></pre>
<h2 id="命令行参数">命令行参数</h2>
<h3 id="命令行方式运行程序">命令行方式运行程序</h3>
<pre><code class="language-bash">notepad sample.txt
</code></pre>
<h3 id="命令行参数-2">命令行参数</h3>
<p>命令行参数：用户在CMD窗口输入可执行文件名的方式启动程序时，跟在可执行文件名后面的那些字符串。</p>
<p>命令行参数可以有多个，以空格分隔，比如：</p>
<pre><code class="language-bash">copy file1.txt file2.txt
</code></pre>
<p><code>copy</code>，<code>file1.txt</code>，<code>file2.txt</code>就是命令行参数。</p>
<p>如果需要获取参数，需要将程序的main函数修改：</p>
<pre><code class="language-c">int main(int argc, char * argv[])
{
	.......
}
</code></pre>
<p>其中：</p>
<p><code>argc</code>：代表启动程序时，命令行参数的个数，C/C++语言规定，可执行程序本身的文件名也算一个命令行参数，因此，<code>argc</code>的值至少是1。</p>
<p><code>argv[]</code>：指针数组，其中每个元素都是一个<code>char*</code>类型的指针，该指针指向一个字符串，这个字符串就存放在命令行参数。</p>
<p>例如：<code>argv[0]</code>指向的字符串就是第一个命令行参数，即可执行程序的文件名，<code>argv[1]</code>指向第二个命令行参数，<code>argv[2]</code>指向第三个命令行参数……。</p>
<p>例程3：</p>
<p>将下面的程序编译成1.3sample.exe，然后在控制台窗口运行。</p>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
int main(int argc, char* argv[]) {
	for (int i = 0; i &lt; argc; i++) {
		printf(&quot;%s\n&quot;, argv[i]);
	}
	return 0;
}
</code></pre>
<p>控制台执行：</p>
<pre><code class="language-bash">1.3sample.exe para1 para2 s.txt 5 &quot;hello world&quot;
</code></pre>
<p>输出结果</p>
<pre><code class="language-bash">1.3sample.exe
para1
para2
s.txt
5
hello world
</code></pre>
<p>命令行参数用空格分隔，如果参数内部有空格，可以用“ ”分隔。</p>
<h2 id="位运算p28">位运算(P28)</h2>
<p>对整数类型（<code>int</code>, <code>char</code>, <code>long</code>等）变量中的某一位（bit），或者若干位进行操作。比如：</p>
<ol>
<li>判断某一位是否为1；</li>
<li>只改变其中某一位，而保持其他位都不变；</li>
</ol>
<p>C/C++语言提供了六种位运算符操作：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>定义</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>按位与，双目</td>
<td>1&amp;1=1, 其余为0</td>
</tr>
<tr>
<td>|</td>
<td>按位或，双目</td>
<td>0|0=0，其余为1</td>
</tr>
<tr>
<td>^</td>
<td>按位异或，双目</td>
<td>1<sup>0=0</sup>1=1, 其余为0</td>
</tr>
<tr>
<td>~</td>
<td>按位非/取反，单目</td>
<td><sub>0=1，</sub>1=0</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移，双目</td>
<td></td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移，双目</td>
<td></td>
</tr>
</tbody>
</table>
<p>注：单目运算符只对一个操作数进行逻辑运算。双目运算符对两个操作数进行逻辑运算。</p>
<h3 id="按位与">按位与“&amp;”</h3>
<p>只有对应的两个二进位均为1时，结果的对应二进制位才为1，否则为0。</p>
<p>例如：21 &amp; 18 = 16；</p>
<p>作用：</p>
<ol>
<li>
<p>通常用来将变量中的某些位清0，同时保留其他位不变。</p>
</li>
<li>
<p>获取某变量中的某一位</p>
</li>
</ol>
<p>例如，需要将<code>int</code>型变量n的低8位全置成0，而其余位不变，则可以执行：</p>
<pre><code class="language-c++">n = n &amp; 0xffffff00
</code></pre>
<p>低8位是0，高24位都是1</p>
<p>按位与的结果，低8位都是0，高24位都不变，也可以写成：</p>
<pre><code class="language-c++">n &amp;= 0xffffff00
</code></pre>
<p>如果n是short类型的，则只需执行</p>
<pre><code class="language-c++">n &amp;= 0xff00
</code></pre>
<p>例题：</p>
<p>如何判断一个<code>int</code>型变量n的第7位（从右往左，从0开始数）是否是1?</p>
<p>只需要看表达式<code>n &amp; 0x80</code>的值是否等于<code>0x80</code>即可，其中<code>0x80: 1000 0000</code></p>
<h3 id="按位或">按位或“|”</h3>
<p>二进位都为0时，结果对应的二进位才是0，否则为1。</p>
<p>例如：21|18=23；</p>
<p>作用：</p>
<p>将某变量中的某些位置1且保留其他位不变。</p>
<p>例如，如果将<code>int</code>型变量n的低8位全置成1，而其余位不变，则可以执行：</p>
<p>n |= 0xff；</p>
<p>0xff：1111 1111</p>
<h3 id="按位异或">按位异或“^”</h3>
<p>两个二进制位不相同时，结果位1，否则为0。</p>
<p>例如：21^18 = 7；</p>
<p>作用：</p>
<p>将某变量中的某些位取反，且保留其他位不变。</p>
<p>例如，将<code>int</code>类型变量n的低8位取反，而其余位不变，则：</p>
<p>n ^= 0xff；</p>
<p>0xff：1111 1111</p>
<p>异或运算的特点：</p>
<p>如果a<sup>b=c，则c</sup>b=a，c^a=b。（穷举法可证），此规律可以用来进行最简单的加密和解密。</p>
<p>作用2：</p>
<p>实现不通过临时变量，交换两个变量的值：</p>
<pre><code class="language-c++">init a = 5, b =7;
a = a ^ b;
b = b ^ a;
a = a ^ b;
</code></pre>
<h3 id="按位非~">按位非“~”</h3>
<p>单目运算符，取反。</p>
<p>例如：~21的值是整型数：0xffffffea；</p>
<p>21：0000 0000 0000 0000 0000 0000 0001 0101</p>
<p>~21：1111 1111 1111 1111 1111 1111 1110 1010</p>
<h3 id="左移运算符">左移运算符“&lt;&lt;”</h3>
<p>表达式：a&lt;&lt;b 的值是：将a各二进位全部左移b位后得到的值。左移时，高位丢弃，低位补0。</p>
<p>例如：9&lt;&lt;4结果的十进制是144。</p>
<p>实际上，左移1位，就等与x2，左移n位，就等于是乘以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>，且左移操作比乘法操作快得多。</p>
<h3 id="右移运算符">右移运算符“&gt;&gt;”</h3>
<p>表达式：a&gt;&gt;b，将a的二进位右移b位，右移时，移出最右边的位被丢弃。</p>
<p>对于有符号数，如long，int，short，char类型变量，右移时，符号位（最高位）将一起移动，并却，大多数C/C++编译器规定，如果原符号位为1，则右移时高位就补充1，原符号位为0，高位补充0。</p>
<p>实际上，右移n位，相当于左操作数除以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>，并且将结果往小里取整。</p>
<p>-25 &gt;&gt; 4 = -2</p>
<p>-2 &gt;&gt; 4 = -1</p>
<p>18 &gt;&gt; 4 = 1</p>
<p>例程：</p>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
int main() {
	int n1 = 15;
	short n2 = -15;
	unsigned short n3 = 0xffe0;
	char c = 15;
	n1 = n1 &gt;&gt; 2;
	n2 &gt;&gt;= 3;
	n3 &gt;&gt;= 4;
	c &gt;&gt;= 3;
	printf(&quot;n1=%d, n2=%x, n3=%x, c=%x&quot;, n1, n2, n3, c);
}//n1=3, n2=fffffffe, n3=ffe, c=1
</code></pre>
<p>结果分析：</p>
<p>其中<code>int</code>类型的变量有32位，占用4个字节，short有16位，unsigned short有16位，char类型有8位，占用1个字节。有符号的数，左边补进来的为符号数。</p>
<p>n1：0000 0000 0000 0000 0000 0000 0000 1111</p>
<p>n1 &gt;&gt;= 2：变成3</p>
<p>n2：1111 1111 1111 0001</p>
<p>n2 &gt;&gt;= 3：变成 fffffffe，即-2</p>
<p>n3：1111 1111 1110 0000</p>
<p>n3 &gt;&gt;= 4：变成ffe（0000 1111 1111 1110）</p>
<p>c：0000 1111</p>
<p>c &gt;&gt;= 3：变成1</p>
<p>思考题：</p>
<p>有两个<code>int</code>型的变量a和n（0&lt;=n&lt;=31），要求写一个表达式，使该表达式的值和a的第n位相同。</p>
<p>（a &gt;&gt; n）&amp; 1</p>
<p>如果n不为31，另一种答案：</p>
<p>（a &amp;（1&lt;&lt; n））&gt;&gt; n</p>
<h2 id="引用的概念和应用">“引用”的概念和应用</h2>
<h3 id="引用的概念p62">引用的概念（P62）</h3>
<p>某个变量的引用，等价于这个变量，相当于该变量的一个别名。</p>
<p>定义方法：类型名 &amp; 引用名 = 某变量名；</p>
<pre><code class="language-c++">int n = 4;
int &amp; r = n;//r引用了n，r的类型是 int &amp;
</code></pre>
<p>例程：</p>
<pre><code class="language-c++">int n = 7;
int &amp; r = n;
r = 4;
cout &lt;&lt; r;//输出4
cout &lt;&lt; n;//输出4
n = 5;
cout &lt;&lt; r;//输出5
</code></pre>
<ul>
<li>
<p>定义引用时，一定要将其初始化成引用某个变量。</p>
</li>
<li>
<p>初始化后，他就一直引用该变量，不会再引用别的变量了。</p>
</li>
<li>
<p>引用只能引用变量，不能引用常量和表达式。</p>
</li>
</ul>
<p>例题：</p>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;iostream&gt;

using namespace std;

int main() {
	double a = 4, b = 5;
	double&amp; r1 = a;
	double&amp; r2 = r1;//r2也引用a
	r2 = 10;
	cout &lt;&lt; a &lt;&lt; endl;//输出10
	r1 = b;//赋值语句，r1并没有引用b
	cout &lt;&lt; a &lt;&lt; endl;//输出5
}
</code></pre>
<h3 id="引用应用的简单示例">引用应用的简单示例</h3>
<p>c语言中，如何编写交换两个整型变量值的函数？</p>
<p>使用指针进行交换整型变量</p>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;iostream&gt;

using namespace std;

void swap(int* a, int* b) {
	int tmp;
	tmp = *a;
	*a = *b;
	*b = tmp;
}

int main() {
	int n1 = 10, n2 = 5;
	cout &lt;&lt; &quot;before swap:&quot; &lt;&lt; n1 &lt;&lt; &quot;,&quot; &lt;&lt; n2 &lt;&lt; endl;
	swap(&amp;n1, &amp;n2);
	cout &lt;&lt; &quot;after swap:&quot; &lt;&lt; n1 &lt;&lt; &quot;,&quot; &lt;&lt; n2 &lt;&lt; endl;
}
</code></pre>
<p>有了C++的引用：</p>
<pre><code class="language-c++">void swap2(int&amp; a, int&amp; b) {
	int tmp;
	tmp = a;
	a = b;
	b = tmp;
}
int n1, n2;
swap(n1, n2);//n1,n2的值被交换
</code></pre>
<p>a，b分别引用了n1，n2，所以，函数里面是等价的。</p>
<h3 id="引用作为函数的返回值p63">引用作为函数的返回值（P63）</h3>
<p>返回值是引用时，可以对其赋值，返回值为n，赋值</p>
<pre><code class="language-c++">int n = 4;
int&amp; SetValue(){
    return n;
}

int main(){
    SetValue() = 40;
    cout &lt;&lt; n;
    return 0;
}//输出：40
</code></pre>
<h3 id="常引用p65">常引用（P65）</h3>
<p>定义引用时，前面加const关键字，即为“常引用”</p>
<pre><code class="language-c++">int n;
const int&amp; r = n;
</code></pre>
<p>r 的类型是<code>const int &amp;</code></p>
<p>不能通过常引用去修改其引用的内容：</p>
<pre><code class="language-c++">int n = 100;
const int&amp; r = n;
r = 200;//编译错
n = 300;//编译没问题
</code></pre>
<h3 id="常引用和非常引用的转换">常引用和非常引用的转换</h3>
<p>const T&amp;和T&amp;是不同的类型！</p>
<p>T&amp;类型的引用或T类型的变量可以用来初始化const T&amp;类型的引用。</p>
<p>const T类型的常变量和const T&amp;类型的引用则不能用来初始化T&amp;类型的引用，除非进行<strong>强制类型转换</strong>。</p>
<h2 id="const关键字的用法">“const”关键字的用法</h2>
<h3 id="1定义常量">1）定义常量</h3>
<p>define也可以定义常量，但是const定义的常量是有类型的</p>
<pre><code class="language-c++">const int MAX_VAL = 23;
const double Pi = 3.14;
const char * SCHOOL_NAME= &quot;Peking University&quot;;
</code></pre>
<h3 id="2定义常量指针">2）定义常量指针</h3>
<p>不可通过常量指针修改其指向的内容，指向的内容是可以被修改的</p>
<pre><code class="language-c++">int n, m;
const int* p = &amp; n;
*p = 5;//编译出错
n = 4;//ok
p = &amp; m;//ok,常量指针的指向可以变化
</code></pre>
<p>不能把常量指针赋值给非常量指针，反过来是可以的。</p>
<p>因为常量指针指向的内容，往往不希望其指向的内容被修改：</p>
<pre><code class="language-c++">const int* p1;
int* p2;
p1 = p2;//ok
p2 = p1;//error
p2 = (int*)p1;//ok,强制类型转换
</code></pre>
<p>函数参数为常量指针时，可避免函数内部不小心改变参数指针所指地方的内容。</p>
<p>避免p所指向内容被修改。</p>
<p>strcpy函数中第一个类型是char *型，不可以用const char *赋值给char *</p>
<pre><code class="language-c++">void MyPrintf(const char* p){
    strcpy(p,&quot;this&quot;);//编译出错
    printf(&quot;%s&quot;,p);//ok
}
</code></pre>
<h3 id="3定义常引用">3）定义常引用</h3>
<p>不能通过常引用修改其引用的变量</p>
<pre><code class="language-c++">int n;
const int&amp; r = n;
r = 5;//error
n = 4;//ok
</code></pre>
<h2 id="动态内存分配">动态内存分配</h2>
<h3 id="用new运算符实现动态内存分配p109">用new运算符实现动态内存分配（P109）</h3>
<p>第一种用法，分配一个变量：</p>
<pre><code class="language-c++">P = new T;
</code></pre>
<p>其中，T 是任意类型名，P 是类型为 T* 的指针。</p>
<p>动态分配出一片大小为sizeof(T) 字节的内存空间，并且将该内存空间的起始地址赋值给P。比如：</p>
<pre><code class="language-c++">int* pn;
pn = new int;
*pn = 5;
</code></pre>
<p>第二种用法，分配一个数组：</p>
<pre><code class="language-c++">P = new T[N];
</code></pre>
<p>T：任意类型名</p>
<p>P：类型为 T* 的指针</p>
<p>N：要分配的数组元素的个数，可以是整型表达式</p>
<p>动态分配出一片大小为 N*sizeof(T)字节的内存空间，并且将该内存空间的起始地址赋值给P。</p>
<p>动态分配数组示例：</p>
<pre><code class="language-c++">int* pn;
int i = 5;
pn = new int[i * 20];
pn[0] = 20;
pn[100] = 30;//编译没问题。运行时导致数组越界
</code></pre>
<p>100个元素的数组的最大合法下标是99</p>
<p>new 运算符的返回值类型：</p>
<p>new T;</p>
<p>new T[n];</p>
<p>这两个表达式返回值的类型都是T *</p>
<pre><code class="language-c++">int* p = new int;
</code></pre>
<h3 id="用delete运算符释放动态分配的内存">用delete运算符释放动态分配的内存</h3>
<p>用“new”动态分配的内存空间，一定要用“delete”运算符进行释放</p>
<pre><code class="language-c++">delete 指针;//该指针必须指向new出来的空间
</code></pre>
<pre><code class="language-c++">int* p = new int;
*p = 5;
delete p;
delete p;//error，一片空间不能被delete多次
</code></pre>
<h3 id="用delete运算符释放动态分配的数组">用delete运算符释放动态分配的数组</h3>
<p>用“delete&quot;释放动态分配的数组，要加“[]&quot;</p>
<pre><code class="language-c++">delete []指针；//该指针必须指向new出来的数组
</code></pre>
<pre><code class="language-c++">int* p = new int[20];
p[0] = 1;
delete[]p;
</code></pre>
<p>delete时如果没加 []，程序不会报错，但是不会把数组释放完全，造成内存的垃圾碎片</p>
<h2 id="内联函数函数重载函数缺省参数">内联函数，函数重载，函数缺省参数</h2>
<h3 id="内联函数p66">内联函数（P66）</h3>
<p>当调用函数产生的开销太大时，可以使用内联函数。</p>
<p>函数调用是有时间开销的，如果函数本事只有几条语句，执行非常块，而且函数被反复执行很多次，相比之下调用函数所产生的这个开销就会显得比较大。</p>
<p>为了减少函数调用的开销，引入了<strong>内联函数</strong>机制。编译器处理对内联函数的调用语句时，是将整个函数的代码插入到调用语句初，而不会产生调用函数的语句。</p>
<p>在函数定义前面加”inline“关键字，即可定义内联函数</p>
<pre><code class="language-c++">inline int Max(int a, int b) {
	if (a &gt; b) return a;
	return b;
}
</code></pre>
<p>坏处：可执行程序的体积变大。</p>
<p>实际调用时：</p>
<pre><code class="language-c++">k = Max（n1, n2)
//编译为：
if (n1 &gt; n2)
tmp = n1;
else tmp = n2;
k = tmp;
</code></pre>
<h3 id="函数重载p67">函数重载（P67）</h3>
<p>一个或多个函数，名字相同，然而<strong>参数个数</strong>或<strong>参数类型</strong>不相同，这叫做函数的重载。</p>
<p>以下三个函数是重载关系：</p>
<pre><code class="language-c++">int Max(double f1, double f2){ }
int Max(int n1, int n2){ }
int Max(int n1, int n2, int n3){ }
</code></pre>
<p>好处：</p>
<p>函数重载使得函数命名变得简单。</p>
<p>编译器根据调用语句的中的实参的个数和类型判断应该调用哪个函数。</p>
<p>例题：</p>
<pre><code class="language-c++">Max(3.4, 2.5);//调用1
Max(2, 4);//调用2
Max(1, 2, 3);//调用3
Max(3, 2.4);//error，二义性
</code></pre>
<p>重载函数：函数名相同，参数不同；</p>
<p>重复定义：函数名相同，参数相同，返回值不同；</p>
<h3 id="函数的缺省参数p61">函数的缺省参数（P61）</h3>
<p>C++中，定义函数的时候，可以让<strong>最右边的连续若干个</strong>参数有<strong>缺省值</strong>，那么调用函数的时候，若相应位置不写参数，参数就是<strong>缺省值</strong>。</p>
<pre><code class="language-c++">void func(int x1, int x2 = 2, int x3 = 3){ }

func(10);//等效于 func(10,3,3)
func(10,8);//等效于 func(10,8,3)
func(10, ,8);//不行，只能最右边的连续若干个参数缺省
</code></pre>
<p>函数参数可缺省的目的：</p>
<p>提高程序的可扩充性。</p>
<p>如果每个写好的函数要添加新的参数，而原先那些调用该函数的语句，未必需要使用新增的参数，那么可以使用缺省参数，避免对原先那些函数调用语句进行修改。</p>

                                </div>
                    </article>
                    <!--  -->
                    
                        <div class="next-post">
                            <div class="next">下一篇</div>
                            <a href="https://zzxll.github.io/post/the-rise-of-modern-china/">
                                <h3 class="post-title">
                                    读书笔记：徐中约（2001）中国近代史
                                </h3>
                            </a>
                        </div>
                        
                            <div id="disqus_thread"></div>
                            <div id="gitalk-container"></div>
                </div>
                <!-- middle -->
                <div class="main-container-middle"></div>
                <!-- right -->
                <div id="sidebar" class="main-container-right">
                    
                        <!-- toc -->
                        
    <div class="toc-card i-card ">
        <div class="toc-title i-card-title">目录</div>
        <div class="toc-content">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88">函数指针</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F">定义形式</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">使用方法</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8Cqsort%E5%BA%93%E5%87%BD%E6%95%B0">函数指针和qsort库函数</a></li>
</ul>
</li>
<li><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0">命令行参数</a>
<ul>
<li><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%96%B9%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F">命令行方式运行程序</a></li>
<li><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0-2">命令行参数</a></li>
</ul>
</li>
<li><a href="#%E4%BD%8D%E8%BF%90%E7%AE%97p28">位运算(P28)</a>
<ul>
<li><a href="#%E6%8C%89%E4%BD%8D%E4%B8%8E">按位与“&amp;”</a></li>
<li><a href="#%E6%8C%89%E4%BD%8D%E6%88%96">按位或“|”</a></li>
<li><a href="#%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96">按位异或“^”</a></li>
<li><a href="#%E6%8C%89%E4%BD%8D%E9%9D%9E~">按位非“~”</a></li>
<li><a href="#%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6">左移运算符“&lt;&lt;”</a></li>
<li><a href="#%E5%8F%B3%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6">右移运算符“&gt;&gt;”</a></li>
</ul>
</li>
<li><a href="#%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8">“引用”的概念和应用</a>
<ul>
<li><a href="#%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5p62">引用的概念（P62）</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E5%BA%94%E7%94%A8%E7%9A%84%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B">引用应用的简单示例</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BCp63">引用作为函数的返回值（P63）</a></li>
<li><a href="#%E5%B8%B8%E5%BC%95%E7%94%A8p65">常引用（P65）</a></li>
<li><a href="#%E5%B8%B8%E5%BC%95%E7%94%A8%E5%92%8C%E9%9D%9E%E5%B8%B8%E5%BC%95%E7%94%A8%E7%9A%84%E8%BD%AC%E6%8D%A2">常引用和非常引用的转换</a></li>
</ul>
</li>
<li><a href="#const%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95">“const”关键字的用法</a>
<ul>
<li><a href="#1%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F">1）定义常量</a></li>
<li><a href="#2%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88">2）定义常量指针</a></li>
<li><a href="#3%E5%AE%9A%E4%B9%89%E5%B8%B8%E5%BC%95%E7%94%A8">3）定义常引用</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">动态内存分配</a>
<ul>
<li><a href="#%E7%94%A8new%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8Dp109">用new运算符实现动态内存分配（P109）</a></li>
<li><a href="#%E7%94%A8delete%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8A%E6%94%BE%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%9A%84%E5%86%85%E5%AD%98">用delete运算符释放动态分配的内存</a></li>
<li><a href="#%E7%94%A8delete%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8A%E6%94%BE%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%9A%84%E6%95%B0%E7%BB%84">用delete运算符释放动态分配的数组</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0">内联函数，函数重载，函数缺省参数</a>
<ul>
<li><a href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0p66">内联函数（P66）</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BDp67">函数重载（P67）</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0p61">函数的缺省参数（P61）</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
        <script>
            function locateCatelogList() {
                /*获取文章目录集合,可通过:header过滤器*/
                var alis = $('.post-content :header');
                /*获取侧边栏目录列表集合**/
                var sidebar_alis = $('.markdownIt-TOC a');
                /*获取滚动条到顶部的距离*/
                var scroll_height = $(window).scrollTop();
                for (var i = 0; i < alis.length; i++) {
                    /*获取锚点集合中的元素分别到顶点的距离*/
                    var a_height = $(alis[i]).offset().top;
                    if (a_height < scroll_height) {
                        /*高亮显示*/
                        sidebar_alis.removeClass('on');
                        $(sidebar_alis[i]).addClass('on');
                    }
                }
            }
            $(function() {
                /*绑定滚动事件 */
                $(window).bind('scroll', locateCatelogList);
            });
        </script>
    </div>
    
                            

                </div>




            </div>


            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://zzxll.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>


    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
    
        
            <script>
    window.onload = function() {
        var gitalk = new Gitalk({
            clientID: 'bf9161dc393f1ad235b2',
            clientSecret: 'a22e1757d1ac285f18ac386dd73b84a759e3209a',
            repo: 'zzxll.github.io',
            owner: 'zzxll',
            admin: ['zzxll'],
            id: (location.pathname).substring(0, 49), // Ensure uniqueness and length less than 50
            distractionFreeMode: false // Facebook-like distraction free mode
        })

        gitalk.render('gitalk-container')
    }
</script>
                

                    
                                
</body>

</html>