<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    学习笔记：程序设计实习 第2周 类和对象初探 | zzxll&#39;s blog
</title>
<link rel="shortcut icon" href="https://zzxll.github.io/favicon.ico?v=1592047435407">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://zzxll.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://zzxll.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


        
            
                <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
                <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
                

                    
                            
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://zzxll.github.io">
                <img class="avatar" src="https://zzxll.github.io/images/avatar.png?v=1592047435407" alt="">
            </a>
            <div class="site-title">
                <h1>
                    zzxll&#39;s blog
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-detail main-container">
                <!-- left -->
                <div id="content" class="main-container-left">
                    <article class="post i-card">
                        <h2 class="post-title">
                            学习笔记：程序设计实习 第2周 类和对象初探
                        </h2>
                        <div class="post-info">
                            <time class="post-time">2020-06-13</time>
                            
                                <a href="https://zzxll.github.io/tag/xue-xi-bi-ji/" class="post-tag i-tag
                            i-tag-">
                            #学习笔记
                        </a>
                                
                                <a href="https://zzxll.github.io/tag/c/" class="post-tag i-tag
                            i-tag-banana">
                            #C++
                        </a>
                                
                                <a href="https://zzxll.github.io/tag/cheng-xu-she-ji-shi-xi/" class="post-tag i-tag
                            i-tag-other_4">
                            #程序设计实习
                        </a>
                                
                        </div>
                        
                                <div class="post-content">
                                    <p>本文是<a href="https://www.bilibili.com/video/av60329215/">“北京大学—程序设计实习[C++]”</a>公开课的听课笔记，配套教材是任课老师自己编写的<a href="https://book.douban.com/subject/11529009/">《新标准C++程序设计教程》</a>，博主是入门菜鸟，故整理并记录在博客里，方便后续查看。</p>
<!-- more -->
<h2 id="浅谈面向对象程序设计方法">浅谈面向对象程序设计方法</h2>
<h3 id="结构化程序设计存在的问题">结构化程序设计存在的问题</h3>
<p>结构化程序设计：复杂的大问题-&gt;层层分解/模块化-&gt;若干子问题</p>
<p>自顶向下，逐步求精</p>
<p>程序=数据结构+算法</p>
<p>存在的问题：理解难，修改难，查错难，重用难；</p>
<h3 id="面向对象的程序设计">面向对象的程序设计</h3>
<p>面向对象的程序=类+类+...+类</p>
<p>面向对象的程序设计方法：</p>
<figure data-type="image" tabindex="1"><img src="https://zzxll.github.io/post-images/1592047162973.png" alt="面向对象的程序设计方法" loading="lazy"></figure>
<!-- more -->
<h3 id="类的定义">类的定义</h3>
<pre><code class="language-c++">class 类名
{
    访问范围说明符：
        成员变量1
        成员变量2
        ……
        成员函数声明1
        成员函数声明2
        ……
    访问范围说明符：
        更多成员变量
        更多成员函数声明
        ……
}
</code></pre>
<h2 id="面向对象程序设计语言的发展历程">面向对象程序设计语言的发展历程</h2>
<p>2011年，提出了c++11标准</p>
<h2 id="从客观事物抽象出类的例子">从客观事物抽象出类的例子</h2>
<p>例：写一个程序，输入矩形的宽和高，输出面积和周长。</p>
<ul>
<li>矩形的<strong>属性</strong>：宽和高
<ul>
<li>两个变量，分别代表宽和高</li>
</ul>
</li>
<li>对矩形的<strong>操作</strong>：
<ul>
<li>设置宽和高</li>
<li>计算面积</li>
<li>计算周长</li>
</ul>
</li>
</ul>
<p>客观事物-&gt;类</p>
<p>矩形类：成员变量+成员函数（可以理解成一个带函数的结构体）</p>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;iostream&gt;

using namespace std;

class CRectangle {
public:
    int w, h;
    void Init(int w_, int h_) {
        w = w_; h = h_;
    }
    int Area() {
        return w * h;
    }
    int Perimeter() {
        return 2 * (w + h);
    }
};//必须有分号

int main() {
    int w, h;
    CRectangle r;//r是一个对象
    cin &gt;&gt; w &gt;&gt; h;
    r.Init(w, h);
    cout &lt;&lt; &quot;the area is &quot; &lt;&lt; r.Area() &lt;&lt; endl &lt;&lt; &quot;the perimeter is &quot; &lt;&lt; r.Perimeter();
    return 0;
}
</code></pre>
<p>类定义的变量--类的实例--“对象”</p>
<h3 id="对象的内存分配">对象的内存分配</h3>
<p>对象的内存空间</p>
<ul>
<li>对象的大小 = 所有成员变量的大小之和</li>
<li>E.g. CRectangle 类的对象，sizeof(Crectangle) = 8，成员变量是两个int类型的，一个int型占4个字节。</li>
</ul>
<p>每个对象各有自己的存储空间，一个对象的某个成员变量被改变，不会影响到其他的对象。</p>
<h3 id="对象间的运算">对象间的运算</h3>
<p>对象之间可以用“=”进行赋值</p>
<p>不能用“==”，“！=”，“&lt;”，“&gt;”，“&lt;=”，“&gt;=”进行比较，除非这些运算符经过了“重载”。</p>
<h3 id="访问类的成员变量和成员函数">访问类的成员变量和成员函数</h3>
<p>用法1：对象名.成员名</p>
<pre><code class="language-c++">Crectangle r1, r2;
r1.w = 5;
r2.Init(3,4);
</code></pre>
<p>用法2：指针-&gt;成员名</p>
<pre><code class="language-c++">CRectangle r1, r2;
CRectangle * p1 = &amp; r1;
CRectangle * p2 = &amp; r2;
p1-&gt;w = 5;
p2-&gt;Init(3,4);//Init作用在p2指向的对象上
</code></pre>
<p>用法3：引用名.成员名</p>
<pre><code class="language-c++">CRectangle r2;
CRectangle &amp; rr = r2;
rr.w = 5;
rr.Init(3,4);//rr的值变了，r2的值也变了
</code></pre>
<p>另一种输出结果的方式</p>
<pre><code class="language-c++">void PrintRectangle(CRectangle &amp; r){
    cout &lt;&lt; r.Area()&lt;&lt;&quot;,&quot;&lt;&lt;r.Perimeter();
}
CRectangle r3;
r3.Init(3,4);
PrintRectangle(r3);
</code></pre>
<h3 id="类的成员函数的另一种写法">类的成员函数的另一种写法</h3>
<p>成员函数体和类的定义分开写，使用<code>::</code>区分</p>
<pre><code class="language-c++">class CRectangle {
pubilc:
	int w, h;
	int Area();//成员函数在此处声明
	int Perimeter();
	void Init(int w_, int h_);
};//一定要有分号

int CRectangle::Area() {
	return w * h;
}

int CRectangle::Perimeter() {
	return 2 * (w + h);
}

void CRectangle::Init(int w_, int h_) {
	w = w_; h = h_;
}
</code></pre>
<p>调用时通过：对象、对象的指针、对象的引用</p>
<h2 id="类成员的可访问范围">类成员的可访问范围</h2>
<p>关键字：类成员可被访问的范围，说明类成员的可见性，缺省时为私有成员。</p>
<ul>
<li>private：指定私有成员，只能在成员函数内被访问</li>
<li>public：指定公有成员，可以在任何地方被访问</li>
<li>protected：指定保护成员，保护成员可以被派生类的成员函数引用</li>
</ul>
<p>三种关键字出现的次数和先后次序都没有限制</p>
<h3 id="对象成员的访问权限">对象成员的访问权限</h3>
<p>定义一个类：</p>
<pre><code class="language-c++">class className{
    private:
    	私有属性和函数
    public:
    	公有属性和函数
    protected:
    	保护属性和函数
}
</code></pre>
<p>举例：</p>
<pre><code class="language-c++">class Man{
    	int nAge;//私有成员
    	char szName[20];
    public:
    	void SetName(char * Name){
            strcpy(szName, Name);
        }
};
</code></pre>
<p>类的成员函数内部，可以访问：</p>
<ul>
<li>当前对象的全部属性，函数</li>
<li>同类其他对象的全部属性，函数</li>
</ul>
<p>类的成员函数以外的地方，可以访问：</p>
<ul>
<li>只能够访问该类对象的公有成员（public）</li>
</ul>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;iostream&gt;

using namespace std;

class CEmployee {
private:
	char szName[30];//名字
public:
	int salary;//工资
	void setName(char* name);
	void getName(char* name);
	void averageSalary(CEmployee e1, CEmployee e2);
};

void CEmployee::setName(char* name) {
	strcpy(szName, name);//ok
}

void CEmployee::getName(char* name) {
	strcpy(name, szName);//ok
}

void CEmployee::averageSalary(CEmployee e1, CEmployee e2) {
	salary = (e1.salary + e2.salary) / 2;
}

int main() {
	CEmployee e;
	char mName[30];//
	//strcpy(e.szName,&quot;Tom123456789&quot;);//编译错，不能访问私有成员
	e.setName(&quot;Tom&quot;);//ok
	e.salary = 5000;//ok
	cout &lt;&lt; e.salary &lt;&lt; endl;
	e.getName(mName);
	cout &lt;&lt; mName &lt;&lt; endl;//输出员工人名
	return 0;
</code></pre>
<p>程序中必须使用接口函数（setName）对私有变量进行修改。</p>
<p><strong>设置私有成员的目的</strong>：</p>
<p>强制对成员变量的访问一定要通过成员函数进行</p>
<p><strong>设置私有成员的机制：</strong></p>
<p>隐藏</p>
<p><strong>程序容易修改：</strong></p>
<p>如szName-&gt;char szName[5]</p>
<p>如果szName不是私有，需要修改全部：</p>
<pre><code class="language-c++">strcpy(man1.szName,&quot;Tom24325435366&quot;);
</code></pre>
<p>如果将szName变为私有，所有对szName的访问都是通过成员函数来进行：</p>
<pre><code class="language-c++">man1.setName(&quot;Tom1234543534635645&quot;);
</code></pre>
<h2 id="内联成员函数与重载成员函数">内联成员函数与重载成员函数</h2>
<h3 id="内联成员函数">内联成员函数</h3>
<p>减少函数调用的开销，内联成员函数的定义方式</p>
<ul>
<li>inline+成员函数</li>
<li>整个函数体出现在类定义内部</li>
</ul>
<pre><code class="language-c++">class B {
	inline void func1();
	void func2() {
		...
	};
};
void B::func1(){}
</code></pre>
<h3 id="成员函数的重载及参数缺省">成员函数的重载及参数缺省</h3>
<p>重载成员函数</p>
<p>成员函数：带缺省参数</p>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Location {
private:
	int x, y;
public:
	void init(int x = 0, int y = 0);
	void valueX(int val) {
		x = val;
	}
	int valueX() {
		return x;
	}
};

void Location::init(int X, int Y) {
	x = X;
	y = Y;
}

int main() {
	Location A;
	A.init(5);//以5，0初始化
	A.valueX(5);//将x设为5
	cout &lt;&lt; A.valueX();//重载成员函数，输出5
	return 0;
}
</code></pre>
<p>使用缺省参数的时候，要注意避免函数重载时的二义性</p>
<pre><code class="language-c++">class Location {
private:
	int x, y;
public:
	void init(int x = 0, int y = 0);
	void valueX(int val = 0) {
		x = val;
	}
	int valueX() {
		return x;
	}
};

Location A;
A.valueX();//error，编译器无法判断调用哪个valueX
</code></pre>
<h2 id="构造函数">构造函数</h2>
<h3 id="基本概念p179">基本概念（P179）</h3>
<ul>
<li>成员函数的一种
<ul>
<li>名字与类名相同，可以有参数，<strong>不能有返回值</strong>（void也不行）</li>
<li>作用是对对象进行初始化，如给成员变量赋初值</li>
<li>如果定义类时没写构造函数，则编译器生成一个默认的无参数的构造函数
<ul>
<li>默认构造函数无参数，不做任何操作</li>
</ul>
</li>
</ul>
</li>
<li>如果定义了构造函数，则编译器不生成默认的无参数的构造函数</li>
<li>对象生成时构造函数自动被调用。对象一旦生成，就再也不能在其上执行构造函数</li>
<li>一个类可以有多个构造函数</li>
</ul>
<p><strong>为什么需要构造函数</strong></p>
<p>1） 构造函数执行必要的初始化工作，有了构造函数，就不必专门再写初始化函数，也不用担心忘记调用初始化函数。</p>
<p>2）有事对象没被初始化就使用，会导致程序错误。</p>
<pre><code class="language-c++">class Complex {
private:
	double real, imag;
public:
	void set(double r, double i);
};//编译器自动生成默认构造函数

Complex c1;//默认构造函数被调用
Complex* pc = new Complex;//默认构造函数被调用
</code></pre>
<p>有构造函数的情况：</p>
<pre><code class="language-c++">class Complex {
private:
	double real, imag;
public:
	Complex(double r, double i = 0);
};
Complex::Complex(double r, double i) {
	real = r;
	imag = i;
}

Complex c1;//error，缺少构造函数的参数
Complex* pc = new Complex;//error，没有参数
Complex cl(2);//ok
Complex c1(2, 4), c2(3, 5);
Complex* pc = new Complex(3, 4);
</code></pre>
<p>上面程序中，new出来的对象返回值是指针。</p>
<p>可以有多个构造函数，参数个数或类型不同：</p>
<pre><code class="language-c++">class Complex {
private:
	double real, imag;
public:
	void Set(double r, double i);
	Complex(double r, double i);
	Complex(double r);
	Complex(Complex c1, Complex c2);
};

Complex::Complex(double r, double i) {
	real = r;
	imag = i;
}

Complex::Complex(double r) {
	real = r;
	imag = 0;
}

Complex::Complex(Complex c1, Complex c2) {
	real = cl.real + c2.real;
	imag = c1.imag + c2.imag;
}

Complex c1(3), c2(1, 0), c3(c1, c2);
//c1 = {3,0}, c2 = {1,0}, c3 = {4,0}
</code></pre>
<p>上面程序中，整型可以自动被转换为double类型。</p>
<h3 id="构造函数在数组中的使用">构造函数在数组中的使用</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class CSample {
private:
	int x;
public:
	CSample(){
		cout &lt;&lt; &quot;Constructor1 Called&quot; &lt;&lt; endl;
	}
	CSample(int n) {
		x = n;
		cout &lt;&lt; &quot;Constructor2 Called&quot; &lt;&lt; endl;
	}
};

int main() {
	CSample array1[2];
	cout &lt;&lt; &quot;step1&quot; &lt;&lt; endl;
	CSample array2[2] = { 4,5 };
	cout &lt;&lt; &quot;step2&quot; &lt;&lt; endl;
	CSample array3[2] = { 3 };
	cout &lt;&lt; &quot;step3&quot; &lt;&lt; endl;
	CSample* array4 = new CSample[2];
	delete[]array4;
	return 0;
}
//输出：
//Constructor1 Called
//Constructor1 Called
//step1
//Constructor2 Called
//Constructor2 Called
//step2
//Constructor2 Called
//Constructor1 Called
//step3
//Constructor1 Called
//Constructor1 Called
</code></pre>
<p>例2：</p>
<pre><code class="language-c++">class Test{
public：
    Test(int n){ }//(1)
    Test(int n, int m){ }//(2)
    Test(){ }//(3)
};
Test array1[3] = {1, Test(1,2)};
//三个元素分别用（1）,（2）,（3）初始化
Test array3[3] = {Test(2,3),Test(1,2),1};
//三个元素分别用（2）,（2）,（1）初始化
Test* pArray[3] = {new Test(4), new Test(1,2)};
//两个元素分别用（1）,（2）初始化，pArray[2]未初始化，是一个未经初始化的指针
</code></pre>
<p>Test* pArray[3]是一个指针数组，不是对象数组，里面每个元素是个指针，不是对象，不会引发对象的生成。</p>
<p>new出来的对象返回值是指针，Test* pArray[3]数组里的指针指向new出来的对象，pArray[0]和pArray[1]分别指向用（1）,（2）初始化的对象，pArray[2]是一个未经初始化的指针</p>

                                </div>
                    </article>
                    <!--  -->
                    
                        <div class="next-post">
                            <div class="next">下一篇</div>
                            <a href="https://zzxll.github.io/post/course-pkupop01/">
                                <h3 class="post-title">
                                    学习笔记：程序设计实习 第1周 从C走进C++
                                </h3>
                            </a>
                        </div>
                        
                            <div id="disqus_thread"></div>
                            <div id="gitalk-container"></div>
                </div>
                <!-- middle -->
                <div class="main-container-middle"></div>
                <!-- right -->
                <div id="sidebar" class="main-container-right">
                    
                        <!-- toc -->
                        
    <div class="toc-card i-card ">
        <div class="toc-title i-card-title">目录</div>
        <div class="toc-content">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%B5%85%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95">浅谈面向对象程序设计方法</a>
<ul>
<li><a href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">结构化程序设计存在的问题</a></li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">面向对象的程序设计</a></li>
<li><a href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89">类的定义</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B">面向对象程序设计语言的发展历程</a></li>
<li><a href="#%E4%BB%8E%E5%AE%A2%E8%A7%82%E4%BA%8B%E7%89%A9%E6%8A%BD%E8%B1%A1%E5%87%BA%E7%B1%BB%E7%9A%84%E4%BE%8B%E5%AD%90">从客观事物抽象出类的例子</a>
<ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">对象的内存分配</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E9%97%B4%E7%9A%84%E8%BF%90%E7%AE%97">对象间的运算</a></li>
<li><a href="#%E8%AE%BF%E9%97%AE%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">访问类的成员变量和成员函数</a></li>
<li><a href="#%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95">类的成员函数的另一种写法</a></li>
</ul>
</li>
<li><a href="#%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E8%8C%83%E5%9B%B4">类成员的可访问范围</a>
<ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90">对象成员的访问权限</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E8%81%94%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8E%E9%87%8D%E8%BD%BD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">内联成员函数与重载成员函数</a>
<ul>
<li><a href="#%E5%86%85%E8%81%94%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">内联成员函数</a></li>
<li><a href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD%E5%8F%8A%E5%8F%82%E6%95%B0%E7%BC%BA%E7%9C%81">成员函数的重载及参数缺省</a></li>
</ul>
</li>
<li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5p179">基本概念（P179）</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8">构造函数在数组中的使用</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
        <script>
            function locateCatelogList() {
                /*获取文章目录集合,可通过:header过滤器*/
                var alis = $('.post-content :header');
                /*获取侧边栏目录列表集合**/
                var sidebar_alis = $('.markdownIt-TOC a');
                /*获取滚动条到顶部的距离*/
                var scroll_height = $(window).scrollTop();
                for (var i = 0; i < alis.length; i++) {
                    /*获取锚点集合中的元素分别到顶点的距离*/
                    var a_height = $(alis[i]).offset().top;
                    if (a_height < scroll_height) {
                        /*高亮显示*/
                        sidebar_alis.removeClass('on');
                        $(sidebar_alis[i]).addClass('on');
                    }
                }
            }
            $(function() {
                /*绑定滚动事件 */
                $(window).bind('scroll', locateCatelogList);
            });
        </script>
    </div>
    
                            

                </div>




            </div>


            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://zzxll.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>


    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
    
        
            <script>
    window.onload = function() {
        var gitalk = new Gitalk({
            clientID: 'bf9161dc393f1ad235b2',
            clientSecret: 'a22e1757d1ac285f18ac386dd73b84a759e3209a',
            repo: 'zzxll.github.io',
            owner: 'zzxll',
            admin: ['zzxll'],
            id: (location.pathname).substring(0, 49), // Ensure uniqueness and length less than 50
            distractionFreeMode: false // Facebook-like distraction free mode
        })

        gitalk.render('gitalk-container')
    }
</script>
                

                    
                                
</body>

</html>