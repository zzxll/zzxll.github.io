<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zzxll.github.io</id>
    <title>zzxll&apos;s blog</title>
    <updated>2021-06-27T06:53:55.679Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zzxll.github.io"/>
    <link rel="self" href="https://zzxll.github.io/atom.xml"/>
    <subtitle>文字上方的logo应该更大一点</subtitle>
    <logo>https://zzxll.github.io/images/avatar.png</logo>
    <icon>https://zzxll.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, zzxll&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[踩坑笔记：WSL2安装CUDA记录]]></title>
        <id>https://zzxll.github.io/post/gpu-cuda-in-wsl/</id>
        <link href="https://zzxll.github.io/post/gpu-cuda-in-wsl/">
        </link>
        <updated>2021-06-27T06:38:07.000Z</updated>
        <summary type="html"><![CDATA[<p>618购入了一张RTX 3060显卡，可以开始愉快的炼丹了。深度学习最正确的姿势当然是装双系统，然后在Linux下进行开发。但听说NVIDIA从去年开始在Windows 10开发版上支持了WSL2调用GPU资源，也就是说配置好之后，就能边用Windows，边用CUDA跑训练，这样再也不用频繁的重启电脑切换系统了，听起来很不错的样子，于是开始踩坑。</p>
]]></summary>
        <content type="html"><![CDATA[<p>618购入了一张RTX 3060显卡，可以开始愉快的炼丹了。深度学习最正确的姿势当然是装双系统，然后在Linux下进行开发。但听说NVIDIA从去年开始在Windows 10开发版上支持了WSL2调用GPU资源，也就是说配置好之后，就能边用Windows，边用CUDA跑训练，这样再也不用频繁的重启电脑切换系统了，听起来很不错的样子，于是开始踩坑。</p>
<!-- more -->
<h2 id="主要参考资料">主要参考资料</h2>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/windows/win32/direct3d12/gpu-cuda-in-wsl">https://docs.microsoft.com/zh-cn/windows/win32/direct3d12/gpu-cuda-in-wsl</a></li>
<li><a href="https://docs.nvidia.com/cuda/wsl-user-guide/index.html#installing-nvidia-drivers">https://docs.nvidia.com/cuda/wsl-user-guide/index.html#installing-nvidia-drivers</a></li>
</ul>
<h2 id="安装过程">安装过程</h2>
<p>安装过程主要参考微软和NVIDIA这两篇文章，照着步骤一步一步做下来就好了，总结流程如下：</p>
<ol>
<li>注册Windows预览体验计划，加入Dev渠道，升级开发者预览版</li>
<li>安装预览版GPU驱动程序（需要注册NVIDIA账号下载）</li>
<li>安装WSL2，和具体的Linux发行版本（只在Ubuntu18.04上安装成功了）</li>
<li>进入WSL2，安装CUDA ToolKit</li>
<li>测试CUDA ToolKit是否安装成功</li>
<li>安装NVIDIA Container Toolkit</li>
<li>测试Dockers是否安装成功</li>
<li>Finish</li>
</ol>
<h2 id="具体遇到的一些问题">具体遇到的一些问题</h2>
<h3 id="windows预览体验计划页面空白刷新不出来">Windows预览体验计划页面空白，刷新不出来？</h3>
<p>设置--隐私--诊断和反馈--诊断数据：勾选可选诊断数据。如果还是刷新不出来，把诊断数据下面的改进墨迹书写和键入的开关打开。</p>
<h3 id="ubuntu2004无法通过apt-get安装cuda-toolkit">Ubuntu20.04无法通过apt-get安装CUDA Toolkit？</h3>
<p>装好WSL2后，一开始装的是Ubuntu20.04的发行版本，无法通过apt-get安装cuda toolkit，可能是自己配置为问题，具体原因未排查。NVIDIA教程中使用的是Ubuntu18.04版本，切换后安装正常。</p>
<h3 id="win10商店无法安装ubuntu发行包点了安装无反应">Win10商店无法安装Ubuntu发行包，点了安装无反应？</h3>
<p>怀疑是微软的BUG，官网有重置应用商店的方法，但自己试了没用。可以通过手动下载 .AppxBundle 文件，然后双击运行安装。</p>
<p>Ubuntu18.04在Windows商店中的网址：https://www.microsoft.com/zh-cn/p/ubuntu-1804-lts/9n9tngvndl3q</p>
<p>应用链接转换网址：https://store.rg-adguard.net</p>
<p>复制Ubuntu18.04的地址进行转换，下载对应的文件：CanonicalGroupLimited.Ubuntu18.04onWindows_1804.2020.824.0_neutral_~_79rhkp1fndgsc.appxbundle</p>
<p>下载比较慢的可以用FDM，IDM这类软件进行下载</p>
<h3 id="dockers版本问题">Dockers版本问题？</h3>
<p>NVIDIA文档中说 NVIDIA Container Toolkit还不支持Docker Desktop WSL2版本，应该用以下指令安装标准版的Docker-CE</p>
<pre><code class="language-bash">curl https://get.docker.com | sh
</code></pre>
<h3 id="pip更换国内源方法">pip更换国内源方法？</h3>
<p>建议更换，下载速度快很多，自己用的是阿里云的，其他国内的源也可以。</p>
<p>复制/etc/apt/sources.list文件备份，删除里面的内容并替换成：</p>
<pre><code class="language-bash">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse
</code></pre>
<p>退出，source一下</p>
<h3 id="anaconda换源方法">anaconda换源方法？</h3>
<p>建议更换成国内的源，下载速度快很多，自己用的是清华源，https://mirrors.tuna.tsinghua.edu.cn/help/anaconda</p>
<p>复制用户根目录下.condarc文件备份，删除里面的内容并替换成：</p>
<pre><code class="language-bash">channels:
  - defaults
show_channel_urls: true
default_channels:
  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main
  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r
  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2
custom_channels:
  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud
  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud
  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud
  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud
  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud
  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud
</code></pre>
<h3 id="安装pytorch出现下载错误">安装pytorch出现下载错误？</h3>
<p>在pytorch官网选好对应的配置，复制conda指令安装，cudatoolkit下载失败的可以在指令后面加 -c conda-forge</p>
<pre><code class="language-bash">conda install pytorch torchvision torchaudio cudatoolkit=11.1 -c pytorch -c nvidia -c conda-forge
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[学习笔记：程序设计实习 第2周 类和对象初探]]></title>
        <id>https://zzxll.github.io/post/course-pkupop02/</id>
        <link href="https://zzxll.github.io/post/course-pkupop02/">
        </link>
        <updated>2020-06-13T11:17:08.000Z</updated>
        <summary type="html"><![CDATA[<p>本文是<a href="https://www.bilibili.com/video/av60329215/">“北京大学—程序设计实习[C++]”</a>公开课的听课笔记，配套教材是任课老师自己编写的<a href="https://book.douban.com/subject/11529009/">《新标准C++程序设计教程》</a>，博主是入门菜鸟，故整理并记录在博客里，方便后续查看。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文是<a href="https://www.bilibili.com/video/av60329215/">“北京大学—程序设计实习[C++]”</a>公开课的听课笔记，配套教材是任课老师自己编写的<a href="https://book.douban.com/subject/11529009/">《新标准C++程序设计教程》</a>，博主是入门菜鸟，故整理并记录在博客里，方便后续查看。</p>
<!-- more -->
<h2 id="浅谈面向对象程序设计方法">浅谈面向对象程序设计方法</h2>
<h3 id="结构化程序设计存在的问题">结构化程序设计存在的问题</h3>
<p>结构化程序设计：复杂的大问题-&gt;层层分解/模块化-&gt;若干子问题</p>
<p>自顶向下，逐步求精</p>
<p>程序=数据结构+算法</p>
<p>存在的问题：理解难，修改难，查错难，重用难；</p>
<h3 id="面向对象的程序设计">面向对象的程序设计</h3>
<p>面向对象的程序=类+类+...+类</p>
<p>面向对象的程序设计方法：</p>
<figure data-type="image" tabindex="1"><img src="https://zzxll.github.io/post-images/1592047162973.png" alt="面向对象的程序设计方法" loading="lazy"></figure>
<!-- more -->
<h3 id="类的定义">类的定义</h3>
<pre><code class="language-c++">class 类名
{
    访问范围说明符：
        成员变量1
        成员变量2
        ……
        成员函数声明1
        成员函数声明2
        ……
    访问范围说明符：
        更多成员变量
        更多成员函数声明
        ……
}
</code></pre>
<h2 id="面向对象程序设计语言的发展历程">面向对象程序设计语言的发展历程</h2>
<p>2011年，提出了c++11标准</p>
<h2 id="从客观事物抽象出类的例子">从客观事物抽象出类的例子</h2>
<p>例：写一个程序，输入矩形的宽和高，输出面积和周长。</p>
<ul>
<li>矩形的<strong>属性</strong>：宽和高
<ul>
<li>两个变量，分别代表宽和高</li>
</ul>
</li>
<li>对矩形的<strong>操作</strong>：
<ul>
<li>设置宽和高</li>
<li>计算面积</li>
<li>计算周长</li>
</ul>
</li>
</ul>
<p>客观事物-&gt;类</p>
<p>矩形类：成员变量+成员函数（可以理解成一个带函数的结构体）</p>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;iostream&gt;

using namespace std;

class CRectangle {
public:
    int w, h;
    void Init(int w_, int h_) {
        w = w_; h = h_;
    }
    int Area() {
        return w * h;
    }
    int Perimeter() {
        return 2 * (w + h);
    }
};//必须有分号

int main() {
    int w, h;
    CRectangle r;//r是一个对象
    cin &gt;&gt; w &gt;&gt; h;
    r.Init(w, h);
    cout &lt;&lt; &quot;the area is &quot; &lt;&lt; r.Area() &lt;&lt; endl &lt;&lt; &quot;the perimeter is &quot; &lt;&lt; r.Perimeter();
    return 0;
}
</code></pre>
<p>类定义的变量--类的实例--“对象”</p>
<h3 id="对象的内存分配">对象的内存分配</h3>
<p>对象的内存空间</p>
<ul>
<li>对象的大小 = 所有成员变量的大小之和</li>
<li>E.g. CRectangle 类的对象，sizeof(Crectangle) = 8，成员变量是两个int类型的，一个int型占4个字节。</li>
</ul>
<p>每个对象各有自己的存储空间，一个对象的某个成员变量被改变，不会影响到其他的对象。</p>
<h3 id="对象间的运算">对象间的运算</h3>
<p>对象之间可以用“=”进行赋值</p>
<p>不能用“==”，“！=”，“&lt;”，“&gt;”，“&lt;=”，“&gt;=”进行比较，除非这些运算符经过了“重载”。</p>
<h3 id="访问类的成员变量和成员函数">访问类的成员变量和成员函数</h3>
<p>用法1：对象名.成员名</p>
<pre><code class="language-c++">Crectangle r1, r2;
r1.w = 5;
r2.Init(3,4);
</code></pre>
<p>用法2：指针-&gt;成员名</p>
<pre><code class="language-c++">CRectangle r1, r2;
CRectangle * p1 = &amp; r1;
CRectangle * p2 = &amp; r2;
p1-&gt;w = 5;
p2-&gt;Init(3,4);//Init作用在p2指向的对象上
</code></pre>
<p>用法3：引用名.成员名</p>
<pre><code class="language-c++">CRectangle r2;
CRectangle &amp; rr = r2;
rr.w = 5;
rr.Init(3,4);//rr的值变了，r2的值也变了
</code></pre>
<p>另一种输出结果的方式</p>
<pre><code class="language-c++">void PrintRectangle(CRectangle &amp; r){
    cout &lt;&lt; r.Area()&lt;&lt;&quot;,&quot;&lt;&lt;r.Perimeter();
}
CRectangle r3;
r3.Init(3,4);
PrintRectangle(r3);
</code></pre>
<h3 id="类的成员函数的另一种写法">类的成员函数的另一种写法</h3>
<p>成员函数体和类的定义分开写，使用<code>::</code>区分</p>
<pre><code class="language-c++">class CRectangle {
pubilc:
	int w, h;
	int Area();//成员函数在此处声明
	int Perimeter();
	void Init(int w_, int h_);
};//一定要有分号

int CRectangle::Area() {
	return w * h;
}

int CRectangle::Perimeter() {
	return 2 * (w + h);
}

void CRectangle::Init(int w_, int h_) {
	w = w_; h = h_;
}
</code></pre>
<p>调用时通过：对象、对象的指针、对象的引用</p>
<h2 id="类成员的可访问范围">类成员的可访问范围</h2>
<p>关键字：类成员可被访问的范围，说明类成员的可见性，缺省时为私有成员。</p>
<ul>
<li>private：指定私有成员，只能在成员函数内被访问</li>
<li>public：指定公有成员，可以在任何地方被访问</li>
<li>protected：指定保护成员，保护成员可以被派生类的成员函数引用</li>
</ul>
<p>三种关键字出现的次数和先后次序都没有限制</p>
<h3 id="对象成员的访问权限">对象成员的访问权限</h3>
<p>定义一个类：</p>
<pre><code class="language-c++">class className{
    private:
    	私有属性和函数
    public:
    	公有属性和函数
    protected:
    	保护属性和函数
}
</code></pre>
<p>举例：</p>
<pre><code class="language-c++">class Man{
    	int nAge;//私有成员
    	char szName[20];
    public:
    	void SetName(char * Name){
            strcpy(szName, Name);
        }
};
</code></pre>
<p>类的成员函数内部，可以访问：</p>
<ul>
<li>当前对象的全部属性，函数</li>
<li>同类其他对象的全部属性，函数</li>
</ul>
<p>类的成员函数以外的地方，可以访问：</p>
<ul>
<li>只能够访问该类对象的公有成员（public）</li>
</ul>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;iostream&gt;

using namespace std;

class CEmployee {
private:
	char szName[30];//名字
public:
	int salary;//工资
	void setName(char* name);
	void getName(char* name);
	void averageSalary(CEmployee e1, CEmployee e2);
};

void CEmployee::setName(char* name) {
	strcpy(szName, name);//ok
}

void CEmployee::getName(char* name) {
	strcpy(name, szName);//ok
}

void CEmployee::averageSalary(CEmployee e1, CEmployee e2) {
	salary = (e1.salary + e2.salary) / 2;
}

int main() {
	CEmployee e;
	char mName[30];//
	//strcpy(e.szName,&quot;Tom123456789&quot;);//编译错，不能访问私有成员
	e.setName(&quot;Tom&quot;);//ok
	e.salary = 5000;//ok
	cout &lt;&lt; e.salary &lt;&lt; endl;
	e.getName(mName);
	cout &lt;&lt; mName &lt;&lt; endl;//输出员工人名
	return 0;
</code></pre>
<p>程序中必须使用接口函数（setName）对私有变量进行修改。</p>
<p><strong>设置私有成员的目的</strong>：</p>
<p>强制对成员变量的访问一定要通过成员函数进行</p>
<p><strong>设置私有成员的机制：</strong></p>
<p>隐藏</p>
<p><strong>程序容易修改：</strong></p>
<p>如szName-&gt;char szName[5]</p>
<p>如果szName不是私有，需要修改全部：</p>
<pre><code class="language-c++">strcpy(man1.szName,&quot;Tom24325435366&quot;);
</code></pre>
<p>如果将szName变为私有，所有对szName的访问都是通过成员函数来进行：</p>
<pre><code class="language-c++">man1.setName(&quot;Tom1234543534635645&quot;);
</code></pre>
<h2 id="内联成员函数与重载成员函数">内联成员函数与重载成员函数</h2>
<h3 id="内联成员函数">内联成员函数</h3>
<p>减少函数调用的开销，内联成员函数的定义方式</p>
<ul>
<li>inline+成员函数</li>
<li>整个函数体出现在类定义内部</li>
</ul>
<pre><code class="language-c++">class B {
	inline void func1();
	void func2() {
		...
	};
};
void B::func1(){}
</code></pre>
<h3 id="成员函数的重载及参数缺省">成员函数的重载及参数缺省</h3>
<p>重载成员函数</p>
<p>成员函数：带缺省参数</p>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Location {
private:
	int x, y;
public:
	void init(int x = 0, int y = 0);
	void valueX(int val) {
		x = val;
	}
	int valueX() {
		return x;
	}
};

void Location::init(int X, int Y) {
	x = X;
	y = Y;
}

int main() {
	Location A;
	A.init(5);//以5，0初始化
	A.valueX(5);//将x设为5
	cout &lt;&lt; A.valueX();//重载成员函数，输出5
	return 0;
}
</code></pre>
<p>使用缺省参数的时候，要注意避免函数重载时的二义性</p>
<pre><code class="language-c++">class Location {
private:
	int x, y;
public:
	void init(int x = 0, int y = 0);
	void valueX(int val = 0) {
		x = val;
	}
	int valueX() {
		return x;
	}
};

Location A;
A.valueX();//error，编译器无法判断调用哪个valueX
</code></pre>
<h2 id="构造函数">构造函数</h2>
<h3 id="基本概念p179">基本概念（P179）</h3>
<ul>
<li>成员函数的一种
<ul>
<li>名字与类名相同，可以有参数，<strong>不能有返回值</strong>（void也不行）</li>
<li>作用是对对象进行初始化，如给成员变量赋初值</li>
<li>如果定义类时没写构造函数，则编译器生成一个默认的无参数的构造函数
<ul>
<li>默认构造函数无参数，不做任何操作</li>
</ul>
</li>
</ul>
</li>
<li>如果定义了构造函数，则编译器不生成默认的无参数的构造函数</li>
<li>对象生成时构造函数自动被调用。对象一旦生成，就再也不能在其上执行构造函数</li>
<li>一个类可以有多个构造函数</li>
</ul>
<p><strong>为什么需要构造函数</strong></p>
<p>1） 构造函数执行必要的初始化工作，有了构造函数，就不必专门再写初始化函数，也不用担心忘记调用初始化函数。</p>
<p>2）有事对象没被初始化就使用，会导致程序错误。</p>
<pre><code class="language-c++">class Complex {
private:
	double real, imag;
public:
	void set(double r, double i);
};//编译器自动生成默认构造函数

Complex c1;//默认构造函数被调用
Complex* pc = new Complex;//默认构造函数被调用
</code></pre>
<p>有构造函数的情况：</p>
<pre><code class="language-c++">class Complex {
private:
	double real, imag;
public:
	Complex(double r, double i = 0);
};
Complex::Complex(double r, double i) {
	real = r;
	imag = i;
}

Complex c1;//error，缺少构造函数的参数
Complex* pc = new Complex;//error，没有参数
Complex cl(2);//ok
Complex c1(2, 4), c2(3, 5);
Complex* pc = new Complex(3, 4);
</code></pre>
<p>上面程序中，new出来的对象返回值是指针。</p>
<p>可以有多个构造函数，参数个数或类型不同：</p>
<pre><code class="language-c++">class Complex {
private:
	double real, imag;
public:
	void Set(double r, double i);
	Complex(double r, double i);
	Complex(double r);
	Complex(Complex c1, Complex c2);
};

Complex::Complex(double r, double i) {
	real = r;
	imag = i;
}

Complex::Complex(double r) {
	real = r;
	imag = 0;
}

Complex::Complex(Complex c1, Complex c2) {
	real = cl.real + c2.real;
	imag = c1.imag + c2.imag;
}

Complex c1(3), c2(1, 0), c3(c1, c2);
//c1 = {3,0}, c2 = {1,0}, c3 = {4,0}
</code></pre>
<p>上面程序中，整型可以自动被转换为double类型。</p>
<h3 id="构造函数在数组中的使用">构造函数在数组中的使用</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class CSample {
private:
	int x;
public:
	CSample(){
		cout &lt;&lt; &quot;Constructor1 Called&quot; &lt;&lt; endl;
	}
	CSample(int n) {
		x = n;
		cout &lt;&lt; &quot;Constructor2 Called&quot; &lt;&lt; endl;
	}
};

int main() {
	CSample array1[2];
	cout &lt;&lt; &quot;step1&quot; &lt;&lt; endl;
	CSample array2[2] = { 4,5 };
	cout &lt;&lt; &quot;step2&quot; &lt;&lt; endl;
	CSample array3[2] = { 3 };
	cout &lt;&lt; &quot;step3&quot; &lt;&lt; endl;
	CSample* array4 = new CSample[2];
	delete[]array4;
	return 0;
}
//输出：
//Constructor1 Called
//Constructor1 Called
//step1
//Constructor2 Called
//Constructor2 Called
//step2
//Constructor2 Called
//Constructor1 Called
//step3
//Constructor1 Called
//Constructor1 Called
</code></pre>
<p>例2：</p>
<pre><code class="language-c++">class Test{
public：
    Test(int n){ }//(1)
    Test(int n, int m){ }//(2)
    Test(){ }//(3)
};
Test array1[3] = {1, Test(1,2)};
//三个元素分别用（1）,（2）,（3）初始化
Test array3[3] = {Test(2,3),Test(1,2),1};
//三个元素分别用（2）,（2）,（1）初始化
Test* pArray[3] = {new Test(4), new Test(1,2)};
//两个元素分别用（1）,（2）初始化，pArray[2]未初始化，是一个未经初始化的指针
</code></pre>
<p>Test* pArray[3]是一个指针数组，不是对象数组，里面每个元素是个指针，不是对象，不会引发对象的生成。</p>
<p>new出来的对象返回值是指针，Test* pArray[3]数组里的指针指向new出来的对象，pArray[0]和pArray[1]分别指向用（1）,（2）初始化的对象，pArray[2]是一个未经初始化的指针</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[学习笔记：程序设计实习 第1周 从C走进C++]]></title>
        <id>https://zzxll.github.io/post/course-pkupop01/</id>
        <link href="https://zzxll.github.io/post/course-pkupop01/">
        </link>
        <updated>2020-05-11T16:18:43.000Z</updated>
        <summary type="html"><![CDATA[<p>本文是<a href="https://www.bilibili.com/video/av60329215/">“北京大学—程序设计实习[C++]”</a>公开课的听课笔记，配套教材是任课老师自己编写的<a href="https://book.douban.com/subject/11529009/">《新标准C++程序设计教程》</a>，博主是C++入门菜鸟，故整理并记录在博客里，方便后续查看。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文是<a href="https://www.bilibili.com/video/av60329215/">“北京大学—程序设计实习[C++]”</a>公开课的听课笔记，配套教材是任课老师自己编写的<a href="https://book.douban.com/subject/11529009/">《新标准C++程序设计教程》</a>，博主是C++入门菜鸟，故整理并记录在博客里，方便后续查看。</p>
<!-- more -->
<h2 id="函数指针">函数指针</h2>
<p>程序运行期间，每个函数都会占用一段连续的内存空间。函数名就是该函数所占内存区域的起始地址（也称入口地址）。可以将函数的入口地址赋给一个指针变量，使该指针变量指向该函数。通过指针变量调用这个函数，这种指向函数的指针变量称为“函数指针”。</p>
<figure data-type="image" tabindex="1"><img src="https://zzxll.github.io/post-images/1589214091310.png" alt="函数指针示意图" loading="lazy"></figure>
<h3 id="定义形式">定义形式</h3>
<p>类型名（*指针变量名）（参数类型1，参数类型2，...）</p>
<p>例如：<code>int(*pf)(int, char);</code></p>
<p>上面表示pf是一个函数指针，函数指针的返回值和参数类型应与指向函数一致：他所指向的函数的返回值类型应该是int，该函数有两个参数，第一个是int类型，第二个时char类型。</p>
<h3 id="使用方法">使用方法</h3>
<p>可以用一个原型匹配的函数的名字，给一个函数指针赋值，通过函数指针调用它所指向的函数，写法为：</p>
<p>函数指针名（实参表）</p>
<p>例如：<code>pf(x, y);</code></p>
<pre><code class="language-c++"># include &lt;stdio.h&gt;
void PrintMin(int a, int b) {
	if (a &lt; b)
		printf(&quot;%d&quot;, a);
	else
		printf(&quot;%d&quot;, b);
}

int main() {
	void(*pf)(int, int); //定义函数指针
	int x = 4, y = 5;
	pf = PrintMin; //给函数指针赋值
	pf(x, y); //使用函数指针
	return 0;
}
</code></pre>
<h3 id="函数指针和qsort库函数">函数指针和qsort库函数</h3>
<p>C语言快速排序库函数：qsort库函数，可以对任意类型的数组进行排序，定义为：</p>
<pre><code class="language-c++">void qsort(void *base, int nelem, unsigned int width, int(*pfCompare)(const void *,const void *));
</code></pre>
<ol>
<li><code>void *base</code>：数组起始位置</li>
<li><code>int nelem</code>：数组元素的个数</li>
<li><code>unsigned int width</code>：每个元素的大小（由此可以算出每个元素的地址）</li>
<li><code>int(*pfCompare)(const void *,const void *)</code>：元素谁在前谁在后的规则</li>
</ol>
<p>函数指针：pfCompare，它指向一个“比较函数”，该比较函数应为以下形式：</p>
<pre><code class="language-c++">int 函数名(const void *elem1, const void *elem2);
</code></pre>
<p>排序就是一个不断比较并交换位置的过程。</p>
<p>qsort函数在执行时，会通过pfCompare指针调用“比较函数“，调用时将要比较的两个元素的地址传给”比较函数“，然后根据“比较函数”返回值判断两个元素哪个更应该排在前面。</p>
<p>比较函数规则：</p>
<ol>
<li>如果<code>* elem1</code>应该排在<code>* elem2</code>前面，则函数返回值是负整数</li>
<li>如果<code>* elem1</code>和<code>* elem2</code>哪个在前面都可以，则函数返回0</li>
<li>如果<code>* elem1</code>应该排在<code>* elem2</code>后面，则函数返回值是正整数</li>
</ol>
<p>实例1：</p>
<p>下面的程序，功能是调用去sort库函数，将一个<code>unsigned int</code>数组按照个位数从小到大进行排序，比如8，23，15三个数，按个位数从小到大排序，应该是23，15，8；</p>
<p>分析：</p>
<p>需要自己定义一个比较规则，编写比较函数</p>
<pre><code class="language-c++">int myCompare(const void* elem1, const void* elem2)
</code></pre>
<p>其中需要注意的是，<code>* elem1</code>是<code>void *</code>类型的指针，编译器不知道<code>elem1</code>指向的元素是多少字节，所以无法编译。这里加了个<code>(usigned int *)</code>的强制转换。</p>
<p>程序：</p>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int myCompare(const void* elem1, const void* elem2) {
	unsigned int* p1, * p2;
	p1 = (unsigned int*)elem1; //&quot;* elem1&quot;非法
	p2 = (unsigned int*)elem2;
	return (*p1 % 10) - (*p2 % 10);
}

#define NUM 5
int main() {
	unsigned int an[NUM] = { 8,123,11,10,4 };
	qsort(an, NUM, sizeof(unsigned int), myCompare);
	for (int i = 0; i &lt; NUM; i++) {
		printf(&quot;%d &quot;, an[i]);
	}
	return 0;
}//输出结果：10 11 123 4 8
</code></pre>
<h2 id="命令行参数">命令行参数</h2>
<h3 id="命令行方式运行程序">命令行方式运行程序</h3>
<pre><code class="language-bash">notepad sample.txt
</code></pre>
<h3 id="命令行参数-2">命令行参数</h3>
<p>命令行参数：用户在CMD窗口输入可执行文件名的方式启动程序时，跟在可执行文件名后面的那些字符串。</p>
<p>命令行参数可以有多个，以空格分隔，比如：</p>
<pre><code class="language-bash">copy file1.txt file2.txt
</code></pre>
<p><code>copy</code>，<code>file1.txt</code>，<code>file2.txt</code>就是命令行参数。</p>
<p>如果需要获取参数，需要将程序的main函数修改：</p>
<pre><code class="language-c">int main(int argc, char * argv[])
{
	.......
}
</code></pre>
<p>其中：</p>
<p><code>argc</code>：代表启动程序时，命令行参数的个数，C/C++语言规定，可执行程序本身的文件名也算一个命令行参数，因此，<code>argc</code>的值至少是1。</p>
<p><code>argv[]</code>：指针数组，其中每个元素都是一个<code>char*</code>类型的指针，该指针指向一个字符串，这个字符串就存放在命令行参数。</p>
<p>例如：<code>argv[0]</code>指向的字符串就是第一个命令行参数，即可执行程序的文件名，<code>argv[1]</code>指向第二个命令行参数，<code>argv[2]</code>指向第三个命令行参数……。</p>
<p>例程3：</p>
<p>将下面的程序编译成1.3sample.exe，然后在控制台窗口运行。</p>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
int main(int argc, char* argv[]) {
	for (int i = 0; i &lt; argc; i++) {
		printf(&quot;%s\n&quot;, argv[i]);
	}
	return 0;
}
</code></pre>
<p>控制台执行：</p>
<pre><code class="language-bash">1.3sample.exe para1 para2 s.txt 5 &quot;hello world&quot;
</code></pre>
<p>输出结果</p>
<pre><code class="language-bash">1.3sample.exe
para1
para2
s.txt
5
hello world
</code></pre>
<p>命令行参数用空格分隔，如果参数内部有空格，可以用“ ”分隔。</p>
<h2 id="位运算p28">位运算(P28)</h2>
<p>对整数类型（<code>int</code>, <code>char</code>, <code>long</code>等）变量中的某一位（bit），或者若干位进行操作。比如：</p>
<ol>
<li>判断某一位是否为1；</li>
<li>只改变其中某一位，而保持其他位都不变；</li>
</ol>
<p>C/C++语言提供了六种位运算符操作：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>定义</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>按位与，双目</td>
<td>1&amp;1=1, 其余为0</td>
</tr>
<tr>
<td>|</td>
<td>按位或，双目</td>
<td>0|0=0，其余为1</td>
</tr>
<tr>
<td>^</td>
<td>按位异或，双目</td>
<td>1<sup>0=0</sup>1=1, 其余为0</td>
</tr>
<tr>
<td>~</td>
<td>按位非/取反，单目</td>
<td><sub>0=1，</sub>1=0</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移，双目</td>
<td></td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移，双目</td>
<td></td>
</tr>
</tbody>
</table>
<p>注：单目运算符只对一个操作数进行逻辑运算。双目运算符对两个操作数进行逻辑运算。</p>
<h3 id="按位与">按位与“&amp;”</h3>
<p>只有对应的两个二进位均为1时，结果的对应二进制位才为1，否则为0。</p>
<p>例如：21 &amp; 18 = 16；</p>
<p>作用：</p>
<ol>
<li>
<p>通常用来将变量中的某些位清0，同时保留其他位不变。</p>
</li>
<li>
<p>获取某变量中的某一位</p>
</li>
</ol>
<p>例如，需要将<code>int</code>型变量n的低8位全置成0，而其余位不变，则可以执行：</p>
<pre><code class="language-c++">n = n &amp; 0xffffff00
</code></pre>
<p>低8位是0，高24位都是1</p>
<p>按位与的结果，低8位都是0，高24位都不变，也可以写成：</p>
<pre><code class="language-c++">n &amp;= 0xffffff00
</code></pre>
<p>如果n是short类型的，则只需执行</p>
<pre><code class="language-c++">n &amp;= 0xff00
</code></pre>
<p>例题：</p>
<p>如何判断一个<code>int</code>型变量n的第7位（从右往左，从0开始数）是否是1?</p>
<p>只需要看表达式<code>n &amp; 0x80</code>的值是否等于<code>0x80</code>即可，其中<code>0x80: 1000 0000</code></p>
<h3 id="按位或">按位或“|”</h3>
<p>二进位都为0时，结果对应的二进位才是0，否则为1。</p>
<p>例如：21|18=23；</p>
<p>作用：</p>
<p>将某变量中的某些位置1且保留其他位不变。</p>
<p>例如，如果将<code>int</code>型变量n的低8位全置成1，而其余位不变，则可以执行：</p>
<p>n |= 0xff；</p>
<p>0xff：1111 1111</p>
<h3 id="按位异或">按位异或“^”</h3>
<p>两个二进制位不相同时，结果位1，否则为0。</p>
<p>例如：21^18 = 7；</p>
<p>作用：</p>
<p>将某变量中的某些位取反，且保留其他位不变。</p>
<p>例如，将<code>int</code>类型变量n的低8位取反，而其余位不变，则：</p>
<p>n ^= 0xff；</p>
<p>0xff：1111 1111</p>
<p>异或运算的特点：</p>
<p>如果a<sup>b=c，则c</sup>b=a，c^a=b。（穷举法可证），此规律可以用来进行最简单的加密和解密。</p>
<p>作用2：</p>
<p>实现不通过临时变量，交换两个变量的值：</p>
<pre><code class="language-c++">init a = 5, b =7;
a = a ^ b;
b = b ^ a;
a = a ^ b;
</code></pre>
<h3 id="按位非~">按位非“~”</h3>
<p>单目运算符，取反。</p>
<p>例如：~21的值是整型数：0xffffffea；</p>
<p>21：0000 0000 0000 0000 0000 0000 0001 0101</p>
<p>~21：1111 1111 1111 1111 1111 1111 1110 1010</p>
<h3 id="左移运算符">左移运算符“&lt;&lt;”</h3>
<p>表达式：a&lt;&lt;b 的值是：将a各二进位全部左移b位后得到的值。左移时，高位丢弃，低位补0。</p>
<p>例如：9&lt;&lt;4结果的十进制是144。</p>
<p>实际上，左移1位，就等与x2，左移n位，就等于是乘以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>，且左移操作比乘法操作快得多。</p>
<h3 id="右移运算符">右移运算符“&gt;&gt;”</h3>
<p>表达式：a&gt;&gt;b，将a的二进位右移b位，右移时，移出最右边的位被丢弃。</p>
<p>对于有符号数，如long，int，short，char类型变量，右移时，符号位（最高位）将一起移动，并却，大多数C/C++编译器规定，如果原符号位为1，则右移时高位就补充1，原符号位为0，高位补充0。</p>
<p>实际上，右移n位，相当于左操作数除以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>，并且将结果往小里取整。</p>
<p>-25 &gt;&gt; 4 = -2</p>
<p>-2 &gt;&gt; 4 = -1</p>
<p>18 &gt;&gt; 4 = 1</p>
<p>例程：</p>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
int main() {
	int n1 = 15;
	short n2 = -15;
	unsigned short n3 = 0xffe0;
	char c = 15;
	n1 = n1 &gt;&gt; 2;
	n2 &gt;&gt;= 3;
	n3 &gt;&gt;= 4;
	c &gt;&gt;= 3;
	printf(&quot;n1=%d, n2=%x, n3=%x, c=%x&quot;, n1, n2, n3, c);
}//n1=3, n2=fffffffe, n3=ffe, c=1
</code></pre>
<p>结果分析：</p>
<p>其中<code>int</code>类型的变量有32位，占用4个字节，short有16位，unsigned short有16位，char类型有8位，占用1个字节。有符号的数，左边补进来的为符号数。</p>
<p>n1：0000 0000 0000 0000 0000 0000 0000 1111</p>
<p>n1 &gt;&gt;= 2：变成3</p>
<p>n2：1111 1111 1111 0001</p>
<p>n2 &gt;&gt;= 3：变成 fffffffe，即-2</p>
<p>n3：1111 1111 1110 0000</p>
<p>n3 &gt;&gt;= 4：变成ffe（0000 1111 1111 1110）</p>
<p>c：0000 1111</p>
<p>c &gt;&gt;= 3：变成1</p>
<p>思考题：</p>
<p>有两个<code>int</code>型的变量a和n（0&lt;=n&lt;=31），要求写一个表达式，使该表达式的值和a的第n位相同。</p>
<p>（a &gt;&gt; n）&amp; 1</p>
<p>如果n不为31，另一种答案：</p>
<p>（a &amp;（1&lt;&lt; n））&gt;&gt; n</p>
<h2 id="引用的概念和应用">“引用”的概念和应用</h2>
<h3 id="引用的概念p62">引用的概念（P62）</h3>
<p>某个变量的引用，等价于这个变量，相当于该变量的一个别名。</p>
<p>定义方法：类型名 &amp; 引用名 = 某变量名；</p>
<pre><code class="language-c++">int n = 4;
int &amp; r = n;//r引用了n，r的类型是 int &amp;
</code></pre>
<p>例程：</p>
<pre><code class="language-c++">int n = 7;
int &amp; r = n;
r = 4;
cout &lt;&lt; r;//输出4
cout &lt;&lt; n;//输出4
n = 5;
cout &lt;&lt; r;//输出5
</code></pre>
<ul>
<li>
<p>定义引用时，一定要将其初始化成引用某个变量。</p>
</li>
<li>
<p>初始化后，他就一直引用该变量，不会再引用别的变量了。</p>
</li>
<li>
<p>引用只能引用变量，不能引用常量和表达式。</p>
</li>
</ul>
<p>例题：</p>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;iostream&gt;

using namespace std;

int main() {
	double a = 4, b = 5;
	double&amp; r1 = a;
	double&amp; r2 = r1;//r2也引用a
	r2 = 10;
	cout &lt;&lt; a &lt;&lt; endl;//输出10
	r1 = b;//赋值语句，r1并没有引用b
	cout &lt;&lt; a &lt;&lt; endl;//输出5
}
</code></pre>
<h3 id="引用应用的简单示例">引用应用的简单示例</h3>
<p>c语言中，如何编写交换两个整型变量值的函数？</p>
<p>使用指针进行交换整型变量</p>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;iostream&gt;

using namespace std;

void swap(int* a, int* b) {
	int tmp;
	tmp = *a;
	*a = *b;
	*b = tmp;
}

int main() {
	int n1 = 10, n2 = 5;
	cout &lt;&lt; &quot;before swap:&quot; &lt;&lt; n1 &lt;&lt; &quot;,&quot; &lt;&lt; n2 &lt;&lt; endl;
	swap(&amp;n1, &amp;n2);
	cout &lt;&lt; &quot;after swap:&quot; &lt;&lt; n1 &lt;&lt; &quot;,&quot; &lt;&lt; n2 &lt;&lt; endl;
}
</code></pre>
<p>有了C++的引用：</p>
<pre><code class="language-c++">void swap2(int&amp; a, int&amp; b) {
	int tmp;
	tmp = a;
	a = b;
	b = tmp;
}
int n1, n2;
swap(n1, n2);//n1,n2的值被交换
</code></pre>
<p>a，b分别引用了n1，n2，所以，函数里面是等价的。</p>
<h3 id="引用作为函数的返回值p63">引用作为函数的返回值（P63）</h3>
<p>返回值是引用时，可以对其赋值，返回值为n，赋值</p>
<pre><code class="language-c++">int n = 4;
int&amp; SetValue(){
    return n;
}

int main(){
    SetValue() = 40;
    cout &lt;&lt; n;
    return 0;
}//输出：40
</code></pre>
<h3 id="常引用p65">常引用（P65）</h3>
<p>定义引用时，前面加const关键字，即为“常引用”</p>
<pre><code class="language-c++">int n;
const int&amp; r = n;
</code></pre>
<p>r 的类型是<code>const int &amp;</code></p>
<p>不能通过常引用去修改其引用的内容：</p>
<pre><code class="language-c++">int n = 100;
const int&amp; r = n;
r = 200;//编译错
n = 300;//编译没问题
</code></pre>
<h3 id="常引用和非常引用的转换">常引用和非常引用的转换</h3>
<p>const T&amp;和T&amp;是不同的类型！</p>
<p>T&amp;类型的引用或T类型的变量可以用来初始化const T&amp;类型的引用。</p>
<p>const T类型的常变量和const T&amp;类型的引用则不能用来初始化T&amp;类型的引用，除非进行<strong>强制类型转换</strong>。</p>
<h2 id="const关键字的用法">“const”关键字的用法</h2>
<h3 id="1定义常量">1）定义常量</h3>
<p>define也可以定义常量，但是const定义的常量是有类型的</p>
<pre><code class="language-c++">const int MAX_VAL = 23;
const double Pi = 3.14;
const char * SCHOOL_NAME= &quot;Peking University&quot;;
</code></pre>
<h3 id="2定义常量指针">2）定义常量指针</h3>
<p>不可通过常量指针修改其指向的内容，指向的内容是可以被修改的</p>
<pre><code class="language-c++">int n, m;
const int* p = &amp; n;
*p = 5;//编译出错
n = 4;//ok
p = &amp; m;//ok,常量指针的指向可以变化
</code></pre>
<p>不能把常量指针赋值给非常量指针，反过来是可以的。</p>
<p>因为常量指针指向的内容，往往不希望其指向的内容被修改：</p>
<pre><code class="language-c++">const int* p1;
int* p2;
p1 = p2;//ok
p2 = p1;//error
p2 = (int*)p1;//ok,强制类型转换
</code></pre>
<p>函数参数为常量指针时，可避免函数内部不小心改变参数指针所指地方的内容。</p>
<p>避免p所指向内容被修改。</p>
<p>strcpy函数中第一个类型是char *型，不可以用const char *赋值给char *</p>
<pre><code class="language-c++">void MyPrintf(const char* p){
    strcpy(p,&quot;this&quot;);//编译出错
    printf(&quot;%s&quot;,p);//ok
}
</code></pre>
<h3 id="3定义常引用">3）定义常引用</h3>
<p>不能通过常引用修改其引用的变量</p>
<pre><code class="language-c++">int n;
const int&amp; r = n;
r = 5;//error
n = 4;//ok
</code></pre>
<h2 id="动态内存分配">动态内存分配</h2>
<h3 id="用new运算符实现动态内存分配p109">用new运算符实现动态内存分配（P109）</h3>
<p>第一种用法，分配一个变量：</p>
<pre><code class="language-c++">P = new T;
</code></pre>
<p>其中，T 是任意类型名，P 是类型为 T* 的指针。</p>
<p>动态分配出一片大小为sizeof(T) 字节的内存空间，并且将该内存空间的起始地址赋值给P。比如：</p>
<pre><code class="language-c++">int* pn;
pn = new int;
*pn = 5;
</code></pre>
<p>第二种用法，分配一个数组：</p>
<pre><code class="language-c++">P = new T[N];
</code></pre>
<p>T：任意类型名</p>
<p>P：类型为 T* 的指针</p>
<p>N：要分配的数组元素的个数，可以是整型表达式</p>
<p>动态分配出一片大小为 N*sizeof(T)字节的内存空间，并且将该内存空间的起始地址赋值给P。</p>
<p>动态分配数组示例：</p>
<pre><code class="language-c++">int* pn;
int i = 5;
pn = new int[i * 20];
pn[0] = 20;
pn[100] = 30;//编译没问题。运行时导致数组越界
</code></pre>
<p>100个元素的数组的最大合法下标是99</p>
<p>new 运算符的返回值类型：</p>
<p>new T;</p>
<p>new T[n];</p>
<p>这两个表达式返回值的类型都是T *</p>
<pre><code class="language-c++">int* p = new int;
</code></pre>
<h3 id="用delete运算符释放动态分配的内存">用delete运算符释放动态分配的内存</h3>
<p>用“new”动态分配的内存空间，一定要用“delete”运算符进行释放</p>
<pre><code class="language-c++">delete 指针;//该指针必须指向new出来的空间
</code></pre>
<pre><code class="language-c++">int* p = new int;
*p = 5;
delete p;
delete p;//error，一片空间不能被delete多次
</code></pre>
<h3 id="用delete运算符释放动态分配的数组">用delete运算符释放动态分配的数组</h3>
<p>用“delete&quot;释放动态分配的数组，要加“[]&quot;</p>
<pre><code class="language-c++">delete []指针；//该指针必须指向new出来的数组
</code></pre>
<pre><code class="language-c++">int* p = new int[20];
p[0] = 1;
delete[]p;
</code></pre>
<p>delete时如果没加 []，程序不会报错，但是不会把数组释放完全，造成内存的垃圾碎片</p>
<h2 id="内联函数函数重载函数缺省参数">内联函数，函数重载，函数缺省参数</h2>
<h3 id="内联函数p66">内联函数（P66）</h3>
<p>当调用函数产生的开销太大时，可以使用内联函数。</p>
<p>函数调用是有时间开销的，如果函数本事只有几条语句，执行非常块，而且函数被反复执行很多次，相比之下调用函数所产生的这个开销就会显得比较大。</p>
<p>为了减少函数调用的开销，引入了<strong>内联函数</strong>机制。编译器处理对内联函数的调用语句时，是将整个函数的代码插入到调用语句初，而不会产生调用函数的语句。</p>
<p>在函数定义前面加”inline“关键字，即可定义内联函数</p>
<pre><code class="language-c++">inline int Max(int a, int b) {
	if (a &gt; b) return a;
	return b;
}
</code></pre>
<p>坏处：可执行程序的体积变大。</p>
<p>实际调用时：</p>
<pre><code class="language-c++">k = Max（n1, n2)
//编译为：
if (n1 &gt; n2)
tmp = n1;
else tmp = n2;
k = tmp;
</code></pre>
<h3 id="函数重载p67">函数重载（P67）</h3>
<p>一个或多个函数，名字相同，然而<strong>参数个数</strong>或<strong>参数类型</strong>不相同，这叫做函数的重载。</p>
<p>以下三个函数是重载关系：</p>
<pre><code class="language-c++">int Max(double f1, double f2){ }
int Max(int n1, int n2){ }
int Max(int n1, int n2, int n3){ }
</code></pre>
<p>好处：</p>
<p>函数重载使得函数命名变得简单。</p>
<p>编译器根据调用语句的中的实参的个数和类型判断应该调用哪个函数。</p>
<p>例题：</p>
<pre><code class="language-c++">Max(3.4, 2.5);//调用1
Max(2, 4);//调用2
Max(1, 2, 3);//调用3
Max(3, 2.4);//error，二义性
</code></pre>
<p>重载函数：函数名相同，参数不同；</p>
<p>重复定义：函数名相同，参数相同，返回值不同；</p>
<h3 id="函数的缺省参数p61">函数的缺省参数（P61）</h3>
<p>C++中，定义函数的时候，可以让<strong>最右边的连续若干个</strong>参数有<strong>缺省值</strong>，那么调用函数的时候，若相应位置不写参数，参数就是<strong>缺省值</strong>。</p>
<pre><code class="language-c++">void func(int x1, int x2 = 2, int x3 = 3){ }

func(10);//等效于 func(10,3,3)
func(10,8);//等效于 func(10,8,3)
func(10, ,8);//不行，只能最右边的连续若干个参数缺省
</code></pre>
<p>函数参数可缺省的目的：</p>
<p>提高程序的可扩充性。</p>
<p>如果每个写好的函数要添加新的参数，而原先那些调用该函数的语句，未必需要使用新增的参数，那么可以使用缺省参数，避免对原先那些函数调用语句进行修改。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[读书笔记：徐中约（2001）中国近代史]]></title>
        <id>https://zzxll.github.io/post/the-rise-of-modern-china/</id>
        <link href="https://zzxll.github.io/post/the-rise-of-modern-china/">
        </link>
        <updated>2020-03-12T08:29:54.000Z</updated>
        <summary type="html"><![CDATA[<p>断断续续地把徐中约老师的<a href="https://book.douban.com/subject/2376486/">《中国近代史》</a>中建国后的部分读完了，书中关于这段历史的论述在“第六编 中华人民共和国的崛起”，下面将阅读时的一些标记进行整理。</p>
]]></summary>
        <content type="html"><![CDATA[<p>断断续续地把徐中约老师的<a href="https://book.douban.com/subject/2376486/">《中国近代史》</a>中建国后的部分读完了，书中关于这段历史的论述在“第六编 中华人民共和国的崛起”，下面将阅读时的一些标记进行整理。</p>
<!-- more -->
<p>本书作者是美国大学的教授，且最初在境外出版，书中的内容不用受到国内审查的约束，因此可以和国内的历史教材相结合，更加全面的了解这段时期的历史。当然，不管是由哪位作者书写，他的文字里总是包含着他的价值观，和他对这段历史的评价。尤其是针对当代的历史，连盖棺定论的时候还没到，市面上肯定也没有绝对客观、公正、详实的史书。而作为普通读者的我们，只有多看看不同人写的文章，国内的、国外的，资本主义的、社会主义的，才能对我们所经历的一些历史事件有更清楚地认识。</p>
<h2 id="第二十六章-中华人民共和国第一个十年">第二十六章 中华人民共和国：第一个十年</h2>
<h3 id="政治组织">政治组织</h3>
<p>政治局又设有常委会，由中国权力最大的七个人组成。在文化大革命之前，这七个人包括中央委员会主席(毛泽东)、五个副主席(刘少奇、周恩来、朱德、陈云和林彪)和党的总书记(邓小平)中央委员会设有六个大区局和一些部委，如组织部、宣传部和社会部等。</p>
<h3 id="经济发展">经济发展</h3>
<p>农村人口被划分成五类： (1) 地主：即那些占有大量地产、自己不劳动、靠高利贷和剥削他人生活的人； (2) 富农：指那些拥有土地、但自己做农活、同时也雇佣雇工、放债并将部分土地出租给贫农的人； (3) 中农：指那些自己有地，但自己耕种、不剥削他人的人； (4) 贫农：指那些占有土地或农具极少、不得不靠卖地过活的人，或是那些不得不租用他人耕地的人； (5) 雇农：指那些不占有土地、不得不靠做工或借贷过活的人。</p>
<p>到1952年12月，土地革命完成了，约七亿亩(一亩合六分之一英亩)的土地分给了三亿农民。在人口密度最高的华东和华南，人均土地面积是一亩；在华中是两到三亩；在华北是三亩；在东北是七亩。总的来说，土地革命牺牲了地主和富农的利益而有利于贫雇农，中农所受的影响则最小。</p>
<p>第一个五年计划预计在 1953 年开始启动，但由于经验不足，也由于缺乏统计知识、计划技术和方法，因此不断被拖延和修改。『一五』计划一直到 1955 年 2 月才最后启动，比规定开始的时间约晚两年，因此实际上只是一个两年半计划。</p>
<h3 id="社会和心理控制">社会和心理控制</h3>
<p>在第二阶段结束之时，受训者十有八九会经历一场精神危机。经过这场思想斗争，他会得出结论，隐瞒和抗拒毫无意义，无论如何党将取胜。于是他寻求解放，抛弃自己的情感，全心全意地接受党和党代表的一切。这样，他就丢掉了包袱，获得了再生。他在共产党的术语和宣传中找到了新的含义，并急于去帮助与他有相似经历的人，这在某种意义上也是为了证明自己的转变完全正确。巩固这种心态大约需要四个月。当受训结束时，四分之一的毕业学员将调派去开办新的学习班，而其余的人则深入社会组织和领导群众。事实上，整个社会就是一座控制大众的实验室。</p>
<p>通过群众组织、秘密警察、大众通讯媒介和思想灌输，政府成功地控制并改造了社会和人民，其程度是中国历史上前所未闻的。曾经是个人主义色彩很重的中国人成为了世界上最受节制的民族。</p>
<h3 id="对外关系">对外关系</h3>
<p>事实上，日内瓦会议和万隆会议使中国取得了亚非国家集团领袖的地位。</p>
<h3 id="初期紧张的征兆">初期紧张的征兆</h3>
<p>一方面为了给人民提供一个发泄怨气的机会，以免匈牙利式的叛乱在中国重演，另一方面也是为了诱导出真正的批评，毛泽东精明地号召『百花齐放，百家争鸣』！许多知识分子天真地误认为这个口号意味着言论自由，于是就袒露出他们的心迹。由此引出的批评超过了政府的预期。毛泽东发现局势难以容忍、极为不利，于是迅速予以镇压。提意见的人被揪住不放，虽然他们为自己的卤莽后悔不已，但要收回说出去的话就太晚了。许多人被送往劳改队，或者被迫签署一份『社会主义自我改造决心书』以改正立场。在这场反右运动刚结束时，政府于1957年在工农业人口中，发动了一场『社会主义教育运动』，接着又派军政干部从事体力劳动，为人民群众树立榜样，更多地强调思想意识的『红』而非『专』。</p>
<h2 id="第二十七章-中苏分裂">第二十七章 中苏分裂</h2>
<h3 id="意识形态争论">意识形态争论</h3>
<p>中国共产党坚持马克思列宁主义的传统观念，认为社会主义世界与资本主义世界之间的战争不可避免。根据北京的观点，战争将推进而非阻挠共产主义事业。第一次世界大战使苏维埃俄国的出现成为可能；第二次世界大战导致了共产党中国的建立；第三次世界大战将使共产党夺取美国的政权，从而埋葬资本主义世界。</p>
<p>相反，由于社会主义阵营具有优越的制度，它将能够通过和平竞赛超过资本主义世界，取得辉煌胜利。</p>
<h3 id="领土争端">领土争端</h3>
<p>3月1-2日夜间，约三百名伪装的中国战士抵达珍宝岛，在一片灌木地带开挖散兵坑，准备打伏击。翌日上午约十一点钟，看上去没带武器的中国人列队走向俄国人；当他们走到敌方面前二十英尺远时，第一排人迅速闪到旁边，第二排人便开枪射击，打死了七名俄国人，包括他们的长官。其它一些中国战士从隐蔽处冲出，一举解决了这支苏军队伍，俘虏了十九名士兵和大批苏军装备。俄国增援部队最后抵达该岛，逐走了中国人。双方都宣称取得了胜利，同时指控对方进行了侵犯。</p>
<h2 id="第二十八章-无产阶级文化大革命">第二十八章 无产阶级文化大革命</h2>
<p>有关人士千方百计地传达这样的印象，即毛泽东是主动作出这个决定的，但实际情况是刘少奇不动声色地『把他挤出了』国家主席职位。 1966 年 10 月，毛泽东本人评价这个事件说：『我对那个决定非常不满，但我无能为力』。他进一步抱怨说，他被当成『死人一样供了起来』。</p>
<h3 id="文化大革命的开始">文化大革命的开始</h3>
<p>文化大革命的第一枪是由上海《解放军报》总编辑姚文元打响的。1965年11月10日的《文汇报》刊登了姚文元的&lt;评新编历史剧『海瑞罢官』&gt;，这篇文章点名批判吴晗。吴晗曾当过大学教授，当时任北京市副市长。</p>
<h3 id="全面清洗">全面清洗</h3>
<p>毛泽东依靠军队来冲击党，这使林彪的权力和威信迅速上升。毛泽东于1966年7月18日返回北京，此时林彪及其军队已确保了北京无虞，林彪成了铁腕人物和坚决支持毛泽东的顶梁柱。8月1日，毛泽东提名林彪担任中央委员会第一副主席，也即权力阶梯中的第二号人物，而刘少奇则跌落到第八号。毛泽东和林彪肩并肩检阅了正在成立的『红卫兵』，毛泽东亲切地称林彪为他『最亲密的战友』。8月5日，毛泽东写了第一张大字报：『炮打司令部!』中央委员会第十一次会议通过了七项重要决定。这次会议将『党内当权派』和『走资派』定为打倒对象。它号召建立『红卫兵』，作为推广运动的『战斗队』，使革命从北京扩大到各省，绕开由刘少奇控制的党组织和共青团。它号召建立各级长久性的『文化革命小组、委员会和代表大会』，运用毛泽东关于群众路线、阶级斗争和矛盾论的思想。1966年11月22日，成立了一个十七人的中央文革小组，由毛泽东的秘书陈伯达《红旗》杂志总编)担任主任，毛泽东的妻子江青担任第一副组长。这个委员会与林彪控制的军队和周恩来控制的国务院一起，成为毛泽东领导下的三头马车。林彪的权力尤其大，在文化大革命后半期，他似乎接管了搞清洗的大权。</p>
<h2 id="第二十九章-林彪的垮台与后果">第二十九章 林彪的垮台与后果</h2>
<h3 id="林彪的崛起">林彪的崛起</h3>
<p>林彪是一个精明的阴谋家，非常清楚自己的崛起有悖于毛泽东『党指挥枪，而决不允许枪指挥党』的格言。他明白自己的地位很脆弱，并且意识到，在他真正成为领袖之前，他的成功是不完全、不确定的。在这一时刻来临之前，他必须竭尽全力保卫胜利的果实，确保继承权。因此，他在公开场合千方百计地表明他绝对忠于毛泽东，总是像一个谦虚的学生一样亦步亦趋地跟在毛泽东身后。但是，在这种谄媚举止的表象背后，他孜孜不倦地扩大对党政军各部门和各省的控制。他的地位变得非常牢固，因此对他的接班权的任何挑战都可能引发大规模的冲突和混乱。从各个方面来看，林彪在1970年的地位显得是固若金汤；他需要做的仅仅是耐心地等待权柄传到他手里。但是，中国共产党的历史充满了变量，只有时间才能表明毛泽东的心裹究竟想些甚么。</p>
<h3 id="林彪的垮台">林彪的垮台</h3>
<p>他没有直接与林彪冲突，而是把陈伯达当作『极左分子』和『政治骗子』开刀，并让那几个林彪手下的军队领导人做检讨，批判陈伯达的观点。</p>
<p>在这份纪要中，毛泽东被冠以『 B-52 』的代号，林彪被叫做『首长』，他的追随者则被称作『联合舰队』。</p>
<p>林彪不顾一切地策划将『五七一』阴谋付诸实施，但一个同谋者突然告了密，此人叫李伟信，属空四军政治部秘书处副处长。</p>
<h2 id="第三十章-中国重入国际社会">第三十章 中国重入国际社会</h2>
<h3 id="中美缓和">中美缓和</h3>
<p>在这样的境况中，任何要求与北京和解的建议都将招徕政治灾难，并会冒被扣上搞绥靖主义和『同悄共产主义』帽子的风险。</p>
<p>1962 年的中印边界冲突和中国的迅速取胜被大肆渲染，加深了华府的忧虑。</p>
<p>鉴于毛泽东批判赫鲁晓夫与西方和平共处的政策，也鉴于苏联对美国的军事威胁更大，美国方面觉得，与莫斯科而非与北京取得缓和似乎更有利，也更可行。</p>
<h2 id="第三十三章-邓小平和中国的新秩序">第三十三章 邓小平和中国的新秩序</h2>
<h3 id="邓小平争取政治控制权">邓小平争取政治控制权</h3>
<p>另一方面，邓小平的两位得力门生被任命为政治局常委，他们是能干的四川省委第一书记赵紫阳和邓小平在党务方面的助手胡耀邦。</p>
<p>华国锋辞去了总理职务，提名赵紫阳做他的接班人。</p>
<h2 id="第三十四章-中美关系正常化">第三十四章 中美关系正常化</h2>
<h3 id="外交关系的正常化">外交关系的正常化</h3>
<p>短小精干的邓小平副总理于1979年1月28日飞抵华府，进行为期九天的访问。这是三十年来中华人民共和国高级官员第一次访问美国，这使华府安排了比通常更豪华、更正式的接待规格。虽然邓小平在中国的正式官衔仅位居第三，但他毫无疑问是中国权力最大的领导人。华府急于想让他看一看美国，感受一下这个国家的创造力和多样性，并理解国会在美国国家政策制定中的重要作用。美国政府私下希望邓小平在台湾问题上讲话和缓，且不要发表甚么刺激苏联的声明。</p>
<h2 id="第三十五章-革命-共和与军阀割据">第三十五章 革命、共和与军阀割据</h2>
<h3 id="快速现代化的后果">快速现代化的后果</h3>
<p>首要的是通货膨胀，这在以前时期几乎是完全不存在的，那时政府有意识地推行一种低工资，低物价的政策。当民众购买能力很小的时候，对货物的需求保持在较低水平，物价也比较稳定。随着工资的提高和政府购买农产品的价格上涨 (1977-1979年间上涨了20-50％ ) ，国家相应地提高了各种商品的销售价格，从而引发了通货膨胀。</p>
<p>科学工作者、知识分子和高干现在形成了一个特权的高级阶层；城市企业工人和基层干部构成了第二阶层，而农民和生活在农村的人则构成最低等级。一些学者和学生被选派出国进修，他们中许多人是高干的直系亲属，这进一步加强了精英主义倾向，扩大了社会分层。</p>
<p>城市中一个普通产业工人每月大约挣 40 美元，外加奖金，而一个农民每月平均的现金收入只有 5-7 美元。一个城市工人收入超过一个农民六到八倍是很平常的事，而科技人员则比农民多收入十几倍。</p>
<h2 id="第三十六章-毛泽东时代的结束">第三十六章 毛泽东时代的结束</h2>
<h3 id="审判四人帮和林彪集团">审判四人帮和林彪集团</h3>
<p>至于林彪集团的六个被告，全部服罪，承认在1971年9月毛泽东视察全国期间，按林彪的命令策划谋杀毛泽东。他们中最年长的陈伯达称无话可说，但请求党给与宽大，这表达了所有六个人的情感。</p>
<p>公诉人江文请求，鉴于江青『特别严重、特别恶劣』的反革命活动，应给与她严厉的处罚(虽然不一定是死刑)。他说了以下这些话，接近于谴责毛泽东：『全国各族人民都明白，毛主席要承担领导责任。他应对他们在文革期间遭受的苦难负有责任。他也应对没能看清林彪和江青反革命集团负责任。』然而，这位公诉人又马上补充说，毛主席对推翻帝国主义、封建主义和官僚资本主义作出了巨大贡献，并领导创立了中华人民共和国和在中国开创社会主义事业。这位公诉人援引邓小平的观点，称毛泽东的功劳是第一位的，错误是第二位的。</p>
<p>1981 年 1 月 25 日，特别法庭宣判江青和张春桥死刑，缓期两年执行。王洪文被判处无期徒刑。姚文元被判处有期徒刑二十年，陈伯达有期徒刑十八年。其它五名将军被分别处以十六到十八年的有期徒刑。</p>
<p>邓小平派人士马上利用这种形势，指责他在粉碎四人帮之后搞『个人崇拜』，在现代化计划中举措失当，强调革命热情而忽视踏实的经济规划。邓小平派人士认为华国锋的领导是毛泽东『错误』政策的延续，它将为心怀不满的极左分子提供一个将来东山再起、反对现任领导层政策的基点。</p>
<p>虽然没有人否认华国锋在粉碎四人帮中所起的关键作用，但中国的报纸越来越多地宣称，这样一个辉煌成就不应该归功于个人，而应该归功于历史发展的规律和人民大众的意愿。随着华国锋的淡出，毛泽东时代接近尾声了。</p>
<h3 id="对毛泽东的评价">对毛泽东的评价</h3>
<p>另一个人事变动是任命总理赵紫阳担任党的副主席，与胡耀邦和邓小平组成了『集体三人团』。</p>
<p>这份党的文件也评价了华国锋；决议虽然对他在粉碎四人帮和某些经济工作中的建设性作用给与了恰当的肯定，但也批评了他的左倾思想。华国锋被称为『凡是派』，凡是毛主席作出的决策，我们都坚决维护，凡是毛主席的指示，我们都始终不渝地遵循，因而使左倾错误得以持续。华国锋参与了『批邓』运动，在出任党的主席后又阻止纠正错案，包括阻挠为受害干部和天安门广场事件平反昭雪。他甚至搞『个人崇拜』。更坏的是，在1977年8月的十一届中央委员会会议上，他阻止检讨文化大革命的努力，反而利用他的权势肯定文革；后来，他也对推行冒进的经济政策负有责任。文件宣称：『很明显，由他来领导纠正党内的『左』倾错误特别是恢复党的优良传统，是不可能的。』胡耀邦主席在庆祝中国共产党成立六十周年(1981年7月1日)的第一份重要讲话中，对毛泽东作了简明扼要的评价。胡耀邦宣称，毛泽东最伟大的贡献是他早先抵制二、三十年代的那种崇拜外国(苏联)经验的『幼稚病』。他创造性地将马克思主义的普遍真理与中国革命的实际情况结合起来，形成了一套适合中国形势的新策略。毛泽东思想是『党的集体智慧的结晶，是中国人民伟大斗争胜利的纪录』，它的创造性丰富了马克思主义的理论宝库。胡耀邦说，因此，它过去，现在，以及将来都是我党的指导原则。</p>
<p>最大的错误是他对人口全然不加控制。包括北京大学校长马寅初在内的一些专家对人口爆炸的严重的经济和社会后果作了警告，但毛泽东争辩说人口问题只在资本主义社会存在。</p>
<p>党怎么能让所有这一切发生的呢？中国人自己很难找出一个适当的答案，但他们最终提出了两种解释。第一种宣称，在中国，像在其他共产主义国家一样，革命政党的领导人在夺取政权期间，被赋予了巨大的决定权和行动自由。一当取得胜利，这种权力集中便有继续下去的趋势；而由于领袖人物显然巨大的贡献，他的追随者们愿意接受他的崇高地位。他的地位最终成为制度化，得到了终生的领袖地位，并且将其它人的劳动成果算在他自己名下。</p>
<p>流传更广的官方解释则探讨中国过去的封建时代对所有人思想和行为造成的深刻影响。官阶和等级制度中高下之分以及家长作用的痕迹随处可见。农民和小生产者不习惯于掌握自己的命运，相反，依赖于作为『救星』的皇帝之仁慈；作为回报，他们向他表示忠诚和感激。因此，由一个人掌握高度集中的权力有着强大的社会先例。即使是中国共产党本身也反映了这种封建影响，造成了无人敢批评家长的情形出现。结果，集体领导和民主集中制成了一句空话：在集体领导中，有一个人比其它人『更平等』，而在民主集中制中，集中压倒了民主。</p>
<p>这些解释无疑都站得住脚，但它们忽略了一个关键的因素：毛泽东牢牢控制了军队、秘密警察、安全系统、8341部队、情报网络和调查机关，这就使与他对抗成为完全不可能的事。那些敢于批评他的人将冒身家性命之险。</p>
<h3 id="新的领导层和新的秩序">新的领导层和新的秩序</h3>
<p>我们必须禁止任何形式的个人崇拜 …… 凡属重大问题，都必须经过党委的集体讨论，作出决定，不能个人说了算。党委的决定，所有成员都必须遵守。各</p>
<h3 id="中国共产主义三十五年回顾">中国共产主义：三十五年回顾</h3>
<p>毛泽东推翻了八大的决定，宣称『八大关于先进的社会主义制度与落后的社会生产力之间的矛盾是主要矛盾的决定是不正确的』，资产阶级和无产阶级之间的斗争、资本主义道路与社会主义道路的斗争，仍然是中国社会的主要矛盾。从此以后，毛泽东就扩大了阶级斗争的范围，挑起了不断的动荡。</p>
<p>党必须记取阿克顿的格言：权力导致腐化，绝对的权力导致绝对的腐化。</p>
<h2 id="第三十七章-建设有中国特色的社会主义">第三十七章  建设有中国特色的社会主义</h2>
<h3 id="工业改革">工业改革</h3>
<p>中国保证将在1997年以后的五十年里不干预香港的社会经济制度，从而实际上达成了一种『一国两制』的协议，邓小平也希望有朝一日将『一国两制』运用到台湾。</p>
<h3 id="未来发展前景">未来发展前景</h3>
<p>其它一些人乐观地预言，如果不发生诸如中苏战争爆发那样的大祸，或者像文化大革命那种规模的大动乱，那么，以年均增长率8％的速度增长的中国国民生产总值，将在2000年以前超过意大利和英国，到2020年时将超过西德和法国。</p>
<p>最重要的因素有： (1) 对马列主义毛泽东思想的信仰和对执政党领导地位的信任不断被侵蚀； (2) 党政部门腐败横行，它将可能导致公共道德的崩溃； (3) 急剧的通货膨胀将尾随价格失控而来，引起大众的不满。</p>
<h2 id="第三十八章-转变中的中国1986-1988年开放政策对文化的影响">第三十八章 转变中的中国，1986-1988年：开放政策对文化的影响</h2>
<h3 id="学生示威">学生示威</h3>
<p>在近代中国历史上，学生的积极热情并不新鲜；在1986年12月事件以前就有过许多先例。最著名的是1919年的五四运动。在最近时期，1985年9月，学生曾抗议日本的新经济侵略和中国政府一意迎合日本的态度。</p>
<p>这次抗议与九一八事变五十四周年纪念恰好重叠。抗议也成了学生表达其它一些愤慨的渠道，如物价高涨、经济犯罪、官僚主义不当行为、高干子女的徇私枉法等。</p>
<p>1985年12月9日，北京大学和清华大学的学生策划的一次示威由于政府干预而流产了。但不满却继续存在。</p>
<p>1986年12月的抗议最早于月初在安徽省会合肥爆发。中国科技大学位于该市的选区范围内，该大学的学生抗议当地党委不与大学协商就指定了八名将来的全国人大代表。</p>
<p>12 月 5 日，总共有三千名学生游行到市政府前，要求民主选举、新闻和集会自由、不受打击报复，并坚持允许媒体报道他们的抗议。他们进一步要求组成高校学生民主联盟。学生的目标是打破党对报纸和学生的控制。当地党委勉强地同意分配给大学选区四个代表席位并将选举推延到 12 月 29 日。学生进而要求改革选举，高呼：『我们要民主。我们要自由。我们要新闻自由。没有民主就没有现代化。』在上海爆发了一场规模宏大的声援运动。 12 月 19 日，约三万名学生和据估计十万名工人游行到市政府。这标志了这场抗议的高潮。在北京，四千名学生游行到天安门广场，焚烧了一捆捆党报《人民日报》。</p>
<p>中共措手不及，无法对此采取果断措施。保守派要求进行强制镇压，但总书记胡耀邦采取了开明的姿态，认为对年轻人的理想主义不应打击，而应将其引向建设性的目标。</p>
<p>时间对政府有利。学生不久就埋头于期终考试，随后又是寒假。总的来说，官方对学生的态度是先松后紧。为了进一步加强中央对在校学生的控制，政府重新在校园开设了军训和政治课，并恢复了在分配毕业生工作之前先送他们到『基层』农场和工厂劳动一年的不得人心的政策。</p>
<p>到月底，他们赢得了邓小平的支持。他们决定要严厉压制学生的骚动，严肃处理胡耀邦，反对资产阶级自由化。《人民日报》的社论宣称：『是该清醒的时候了。资产阶级自由化确实是一种思潮，它正在毒害我们的青年，危害社会的安定团结，干扰我们的改革和开放，阻碍现代化的进程，难道我们还能够若无其事吗 ? 』在新年来临之际，中央告诫全体党员要增强对『资产阶级自由化』在中国扩散的警惕性。总书记胡耀邦的命运危如累卵了。</p>
<p>邓小平宣称知识分子是工人阶级的一部分，既要得到应有的尊重，也应该从国家得到较好的待遇 —— 不再像毛泽东时代那样是处在社会最底层的『臭老九』了。受他们新的地位的鼓舞，具有独立见识的作家、艺术家、科学家和思想家开始表达他们的心声，关注社会和政治问题。</p>
<p>著名天体物理学家方励之孜孜不倦地倡导人权和民主。他被誉为中国的『萨哈罗夫』，经常到各大学和研究机构露面，作巡回演讲。他最喜欢谈的话题是法治、自由选举、言论自由、出版自由和政治多元化。他深信，学者具有对时代的重要问题发表内心看法的社会责任。他称他不害怕任何人，愿意承担行动的后果。</p>
<p>《人民日报》的采访记者刘宾雁和作家王若望不适余力地揭露官僚主义的阴暗面和官方对文学和出版的控制。</p>
<p>刘宾雁斥责国人受四种幻想的蒙蔽：(1)社会主义是完美的；(2)共产党是永远正确的；(3)马克思列宁主义是永恒的真理；(4)社会主义与资本主义之间存在着深刻的鸿沟，过去几百年里资本主义社会中发生的任何东西没有一样应该予以适当的承认。</p>
<p>邓小平曾同意接受哥伦比亚广播公司 (CBS) 记者华莱士 (Mike Wallace) 的采访，并宣称中国的社会主义将允许一些人先富起来，但要防止富人和穷人之间出现两极分化。邓小平认为，无论如何，在中国的社会主义制度下，是很难有人能成为百万富翁的，因此不用担心中国会出现一个新的资本家阶级。</p>
<p>在党内，对这种新趋势的反应是各种各样的。总书记胡耀邦对之采取一种放任自流的态度，他相信，世界性的讯息革命已经使各国相互紧密地联系在一起，检验新的观念并为中国的共产主义创造一种新的形象符合中国的利益。</p>
<p>胡耀邦的解职学生骚动的一个最大后果是总书记胡耀邦的下台，他太开明了，太直率了。他在总书记职位上坐了五年(1981-1986年)，主要是由于邓小平的支持，邓小平曾推荐他做自己的接班人，并曾放心地说过，有胡耀邦管党，赵紫阳管政府，就是天塌下来他也不怕。</p>
<p>胡耀邦或许天真地把邓小平的话当真了，这样就触怒了他，导致邓小平怀疑起胡耀邦政治上是否足够精明。</p>
<p>当胡耀邦作了自我批评并提出辞职以后，四十个与会者中有二十一个人发言批评他，包括一些他从前最紧密的同盟者。胡耀邦泪流满面，但同意『永不翻案』。问题的解决结果是，胡耀邦维持他政治局委员和中央委员的地位。对他不作公开批评。事实上，他的名望骤增了。</p>
<p>一旦接触到了某些自由和电视、冰箱之类的物质享受，人们就无法忍受退回到毛泽东时代斯巴达式 (Spartan) 的朴素生活了。</p>
<p>赵紫阳总理内心里是个专家治国论者，他与强硬派虚与委蛇，避免对立。他只同他们在1987年5月13日的政治局扩大会议上对抗过一次，试图约束他们过分的左倾思潮。</p>
<h3 id="中共十三大">中共十三大</h3>
<p>万众期待的中共十三大于1987年10月25日到11月1日在北京人民大会堂召开，与会代表1,936人，代表全党4,600万党员。</p>
<p>第二，通过长征一辈的老同志主动引退，大会实现了领导集体的更新，并确保了较年轻的、受过更好教育的技术专家填补他们的职位。</p>
<p>随着保守派的大部分批评被抑制，改革派获得了全速前进的授权。但是，他们知道，退休的老人没有放弃他们的影响。他们愿意退休或许是因为达成了这样的谅解：他们支持的人选李鹏将任命为政治局常委，并将在以后出任总理。事实上，在十三大闭幕后刚过了三周，李鹏就被任命为代总理，随后在1988年3月的全国人民代表大会上被正式任命为总理。</p>
<h3 id="动荡中的社会通货膨胀和道德败坏">动荡中的社会：通货膨胀和道德败坏</h3>
<p>在 1988 年 6 月，这些私营企业有 225,000 家，雇用 360 万人。国家承认这些企业合法，理由是它们有助于生产力的发展。许多个体户成为百万富翁。辽宁沈阳的一个农民组织了一个运输队， 1987 年赚了一百万元人民币。另一位企业家投资一百万元建一座轧钢厂，雇用的在册员工有一百人。福州市一位 31 岁的年轻人经营一家柯达胶卷冲印店，控制有 53.9 万美元的资产，住在一幢价值 10.8 万美元、带空调的房子里。一位木雕『大王』雇用三千名工人，积聚了两千万美元的资产。北京的一位摩托车头盔制造商经营极其成功，以致一家外国公司主动提出与他合股，支付他 82,000 美元的年薪。在较小的规模上，许多没甚么文化的个体经营者一小店铺主、茶农、出租车主 —— 一年挣三万到十万元，是教授和外科医生年薪的十到三十倍。并不令人吃惊的是，一些最缺钱的人转而犯罪，从事盗挖古墓的勾当，希望立即致富。</p>
<h2 id="第三十九章-台湾的经济奇迹及与中国大陆统一的前景">第三十九章 台湾的『经济奇迹』及与中国大陆统一的前景</h2>
<p>值得注意的是，在台湾，财富并没有集中到少数人手里，而是由大多数人分享，充分实现了『均富』的古代理想。1952年，受薪阶层中工资最高的20％与最低的20％之间收入的比例为15：1，但1964年只有5.33：1了，到1987年更降至4.69：1，比美国的工资差别还要小。</p>
<h3 id="台湾经济成功的原因">台湾经济成功的原因</h3>
<p>他自愿放弃了蒋氏家族对国民党的控制，放松了党对政治权力的垄断，从而为法律和民主的发展铺平了道路。</p>
<h3 id="统一的前景">统一的前景</h3>
<p>台湾越来越民主，1992年的人均收入达到10,215美元，相比之下，大陆继续实行列宁主义的专制统治，人均收入只有350美元。</p>
<h2 id="第四十章-天安门广场的武力镇压">第四十章 天安门广场的武力镇压</h2>
<h3 id="黑云压城">黑云压城</h3>
<p>国家主席杨尚昆和总理李鹏威胁称，如果方励之夫妇出席的话，他们将不参加宴会。但是，他们最终接受了这样的妥协：布殊总统将不走到方励之夫妇桌前与他们干杯。但即便是这样安排，对中共来说也是一个极大的侮辱。在最后时刻，中国领导人改变了主意，派警察前往阻止方励之夫妇出席宴会。布殊对这个意外一无所知，整个宴会期间一直以为客人中有方氏夫妇俩人。</p>
<h3 id="党的分裂">党的分裂</h3>
<p>也许是想让所有在场的人感到恐惧，年届 85 岁的老经济专家陈云作了一篇激动的发言：『我们经过了几十年的奋力拼搏夺取政权，建立了中华人民共和国。在这过程中，我们的千百万革命英雄丢掉了生命。我们难道仅仅为了满足学生就放弃这一切吗？』</p>
<p>邓小平宣布他不怕国内外舆论，也不怕任何对抗中的流血牺牲。5月19日他前往武汉，召集了一次军委扩大会议，目的是为他的镇压政策争取支持；并且，一旦北京局势恶化，就可能在这里设立『第二司令部』。</p>
<h3 id="老人政治的心态">老人政治的心态</h3>
<p>镇压政策根源于对学生的企图有意或无意的误解。学生们要求与政府一道采取反腐败的措施，与政府领导人讨论民主、言论自由、集会自由和新闻自由的前景，这些东西是大多数现代文明国家中基本的权利。当政府拒绝倾听他们的心声时，受挫的学生叫喊要李鹏、邓小平和杨尚昆下台。但学生们既没有方法也没有力量赶他们下台或推翻政府。学生们缺乏目标纲领、行动计划，也缺少一个经验丰富、魅力超群、能够代表他们的意愿并将各个零散团体团结起来的领袖。</p>
<p>在宣布戒严令后，政府领导人便不再露面，一直到镇压之后才重出。但是，趟紫阳在5月19日作了最后一次公开露面，他去探望广场上饥饿的绝食者，并为自己的姗姗来迟而道歉。稍后，他就遭到撤职。6月24日，江泽民被任命为新的总书记。</p>
<h3 id="屠杀">屠杀</h3>
<p>邓小平本人的军戎生涯和政治镇压经验足以使他从容应付时局。他在 1948 年后期曾在内战中参与指挥淮海战役，用坦克和大炮消灭国民政府敌军。在 1957 年的反右运动期间，邓小平是中共中央总书记，负责迫害五十多万知识分子，他办事认真、一丝不苟，赢得了毛泽东的高度赞扬。</p>
<p>一些教授悄悄地力劝学生疏散，因为他们已经达到了目的。但学生不愿离开。他们预定 6 月 20 日为撤离的日期，这一天将召开全国人大紧急会议。时间一天天过去，对军事进攻逼近的恐惧感与认为不会发生暴力的放松感交替出现。但每个人在心底里都知道，流血是不可避免的。</p>
<p>6 月 16 日，中国政府发言人袁木告诉 NBC 新闻播音员布罗考 (Tom Brokaw) ：『在整个清场过程中，没有发生任何伤亡 ( 原文如此 ) 。没有人被打死或被装甲车的车轮碾死。国外称血流成河和许多人被压死的报道是不正确的。』但是，政府承认，有二十三名学生在广场外面被意外打死，同时有五千名战士受伤，其中一百五十人死亡。</p>
<h3 id="重写历史">重写历史</h3>
<p>希特勒的宣传部长戈培尔 (Joseph Goebbels) 是『大谎言』理论的发明者，他宣称，谎言越大，人们相信它的可能性就越大。</p>
<p>政府的报纸连篇累牍地刊登有关天安门广场上所发生的事情，但大多数城市居民不相信这个『弥天大谎』，然而相当一些与城市生活隔离的农村居民也许接受了官方的说法。</p>
<p>但现在，这个形象遭受了无法修补的损害。镇压招致了全世界几乎普遍的谴责，还有种种经济和军事制裁。另外，中国还明显地被排斥在重要的外交会议之外。与香港和台湾的关系更是遭到了严重的打击。一百万香港居民示威游行，抗议天安门广场大屠杀，并表示不信任北京允许香港的资本主义生活方式在 1997 年以后五十年不变的承诺。至于跟台湾的统一，前景变得比以往任何时候都更为遥远了。最可悲的是，中国人民的精神受到了致命的伤害，他们将在很长一段时间里无法忘记镇压的痛苦经历、也不会宽恕任何人。</p>
<h2 id="第四十一章-中国的发展模式">第四十一章 中国的发展模式</h2>
<h3 id="第十四次党代表大会">第十四次党代表大会</h3>
<p>僵化强硬保守派在选举中处境凄凉，三名大将(高荻、王忍之、贺敬之)丢了中央委员席位，从传媒、宣传和文化领域的岗位上给撤换下来。这一变动预示了艺术、文化和智识生活中比较自由的气氛。被称为『太子党』的高干子弟们，这回也颇不顺心。陈云的儿子陈元未能当选中央委员。他们当中许多人改弦更张，选择弃政从商。</p>
<p>有二十名成员的政治局，也出现大规模的重组。两位新改革派加入——副总理邹家华和外长钱其琛；</p>
<h3 id="中国共产主义四十五周年独裁政治下的准资本主义">中国共产主义四十五周年：独裁政治下的准资本主义</h3>
<p>数年前，一个年收入一万元的家庭即被视为富有。到 1993 年，家财百万才算有钱。而在广东省，这样的阔人已达四万。据说在全中国，百万富翁已有五百万之众。</p>
<p>乘坐着奥迪汽车、由专职司机驾驶的当地党委书记，对自己新角色的认识也变成：『我最重要的工作就是抓好经济。这儿的人都说：『经济上去了，你就是好领导，要不然就不是。』』</p>
<h3 id="中美关系最惠国待遇">中美关系：最惠国待遇</h3>
<p>关于北京的领导人，佩萝西说：『他们可能不喜欢资本主义，也可能不喜欢人权，但他们喜欢钱。』由她发起，众议院在 1991 年 11 月以 409 票对 21 票通过了一项议案：如果中国想得到 1992 年的最惠国待遇，就需要释放所有在天安门事件中被捕的约一千人，停止向叙利亚和伊朗出售远程导弹，在言论自由、新闻自由、国内和西藏的宗教自由方面表现出『进步』，并『保证』不出售核技术，以及停止向美国出口服刑劳工产品。</p>
<p>克林顿竭力要找出一个一揽子的方案解决，包括贸易逆差，军火交易、人权、服刑劳工和藏人受迫害等一系列问题。</p>
<p>国务卿克里斯托佛根据中国在下列领域的表现，提交报告：1．释放政治犯或说明政治犯的情况。2．保证所有犯人受到人道的对待，并允许国际人权组织如红十字会视察监狱。3．保护西藏独特的宗教和文化传统。4．允许国际广播和电视节目进入中国。5．禁止服刑劳工产品出口美国。6．停止对美国企业的歧视。7．遵守国际上有关限制导弹技术和核材料转移的条约。</p>
<p>从更大的视角来看，总统的行动反映了新时代的精神，在这个时代中经济利益支配着外交政策的决定，最重要的是利润而不是原则。这种转变标志着天安门事件主导外交时代的结束，一个提升国际商业交往、重视科学、教育和文化交流的时代开始了。</p>
<h2 id="第四十二章-中国的崛起">第四十二章 中国的崛起</h2>
<h3 id="香港回归">香港回归</h3>
<p>英国的殖民统治在1842-1997年的一百五十六年间，香港一直作为英国殖民地，由拥有绝对权力的总督实施全面治理。香港的法律不得违背英国议会颁布的决定。直到1985年，英国议会通过了《香港法案》，才赋予香港立法机构有修订或拒绝英国法案与决定的权利。在实践中，总督对香港的统治是相当宽松的，他不干预小区的事务，对传统风俗、宗教活动、社会习俗相当尊重。总督的职责是维持高效率的管治、法律制度、司法独立、良好的公共秩序、公民权利，以及公平和合理的竞争精神。这是一种仁政的殖民管理，在很大程度上对经济繁荣提供了必要的条件。</p>
<p>在政治上，英国从来没有将民主制度赋予香港，直到殖民统治的最后几年，才开始改变这种情况。从香港人自身方面看，他们不曾有过民主诉求，对自己主要致力于追求经济成功、过着『世界公民』式的生活感到满意。</p>
<p>第二个危机是1997年秋天爆发由H5N1病毒引起的『禽流感』。导致130万只各类家禽被宰杀。虽然这次感染得到成功抑制，但对香港的商业，特别是餐饮业来讲，仍然是一次巨大打击。</p>
<h3 id="中美关系">中美关系</h3>
<p>衡量一个国家的实力有八条或九条标准： (1) 人口和领土； (2) 自然资源； (3) 经济实力； (4) 军事力量； (5) 战略和地理重要性； (6) 科学和技术成就水平； (7) 国际组织的参与情况和投票权； (8) 文化与教育水平；以及 (9) 在困难的情况下坚决贯彻国家政策的意愿和决心。</p>
<h3 id="二十一世纪初的中国">二十一世纪初的中国</h3>
<p>在政治上，中国政府正在寻求用一种统合的哲学取代行将就木的共产主义意识形态。这种哲学看起来应类似一种包含着传统儒学、爱国主义、民族主义和少许反映历史上王朝观念的『大中华主义』所组成的混合体。</p>
<p>前四位领导人：国家主席江泽民、副主席胡锦涛、总理朱镕基，人大委员长李鹏，都是大学毕业的工程师，他们将毫不犹豫地在二十一世纪将中国带入科学和信息新时代。</p>
<p>民众对此有何看法 ? 他们对缺乏政治自由感到遗憾，但还是接受了这是为换取社会稳定和经济繁荣的代价。他们觉得生活总的来说要比 1949 年人民共和国成立后的任何一段时期都自由得多。他们有了选择工作、伙伴和居住的自由，可以购买汽车、旅行，生活水平确实得到大大提高。在过去，许多休闲享受被禁止，现在则听凭自便。他们普遍持有乐观的看法，认为自己的国家注定要起飞，明天的生活会更美好。他们渴望像其它文明国家居民那样生活。由于政府不再负责毕业分配，大学毕业生面对着更多的经济上的选择。他们变得更实际，忙于谋划自己的事业，梦想着赚钱或出国深造。他们没有时间为政治原因去参加游行和示威。</p>
<p>人们憎恶任何社会大动乱，例如文化革命，或导致社会和经济的大混乱的秩序破坏，就像共产党垮台后俄罗斯所出现的那样。他们不主张在中国以暴力推翻共产主义体制，但主张内部和平变革，使它能更清醒、更敏锐地应付时代的挑战。通过微小进步的累积过程，一个更自由的政治制度最终一定会出现。他们希望中国融入到世界主流之中。</p>
<p>他们对香港回归、中国成为区域强国，以及到2020年将成为令人刮目相看的世界强国而感到骄傲。他们赞成与台湾和平统一，但不要设时间表。他们相信时间会站在他们一边，最终这两者会变为一体。</p>
<p>新的富裕阶层——企业家、金融家、投资人、计算机大亨、公司经理和商业巨头——会要求更大的政治参与和法治，同时也会要求立法和预算上的发言权。政府将被迫在一定程度上给予言论、集会、出版的自由和宗教信仰、创作、艺术表达及地方选举的自由。通过静悄悄的和平演变，一种中国式的、有节制的民主政体将应运而生。</p>
<p>如果它是某种类似 1919 年五四运动以来学者和政治家们所追求的那种政体——中西文化精华的结合，完全现代化同时又具有鲜明的中国特色——它一定会为大多数中国人所接受。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Markdown基本语法]]></title>
        <id>https://zzxll.github.io/post/markdown-syntax/</id>
        <link href="https://zzxll.github.io/post/markdown-syntax/">
        </link>
        <updated>2020-03-11T09:57:02.000Z</updated>
        <summary type="html"><![CDATA[<p>Markdown是一种轻量级标记语言，目前还没有统一的语法标准，目前较为通用的是GitHub基于CommonMark提出的GFM正式规范。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Markdown是一种轻量级标记语言，目前还没有统一的语法标准，目前较为通用的是GitHub基于CommonMark提出的GFM正式规范。</p>
<!-- more -->
<h2 id="markdown格式标记符号说明">Markdown格式标记符号说明</h2>
<h3 id="1-标题">1. 标题</h3>
<p>使用#数量表示标题级数</p>
<h3 id="2-有序列表">2. 有序列表</h3>
<p>在行首使用<code>1.</code>,<code>2.</code>,<code>3.</code>表示</p>
<ol>
<li>有序列表1</li>
<li>有序列表2</li>
<li>有序列表3</li>
</ol>
<h3 id="3-引用">3. 引用</h3>
<p>使用<code>&gt;</code> 表示文字引用</p>
<blockquote>
<p>为知笔记Markdown新手指南：http://www.wiz.cn/feature-markdown.html</p>
</blockquote>
<h3 id="4-图片">4. 图片</h3>
<p>插入图片的路径可以使用相对路径，绝对路径和网络途径</p>
<p>相对路径：<code>![图片说明](media/picture.jpeg)</code></p>
<p>绝对路径：网络路径与上述格式相同</p>
<h3 id="5-链接">5. 链接</h3>
<p>为文字插入跳转链接，格式为<code>[描述](链接地址)</code>，其中链接地址可以为文件名。</p>
<p>例如：<a href="http://www.wiz.cn">为知笔记</a></p>
<h3 id="6-代码">6. 代码</h3>
<p>代码可分为行内代码和段落代码，在使用一对反单引号可以插入行内代码，三个反单引号进行整段代码输入，在单引号后紧接具体编程语言，可以对代码高亮进行优化。</p>
<h3 id="7-目录">7. 目录</h3>
<p>使用<code>[TOC]</code>插入目录</p>
<h3 id="8-公式">8. 公式</h3>
<p>公式可分为行内公式和块级公式，分别使用<code>$公式1$</code>和<code>$$公式2$$</code>表示</p>
<h3 id="9-表格">9. 表格</h3>
<ol>
<li><code>| 为知笔记|更新 | 版本 |</code></li>
<li><code>|------|----|----|</code></li>
<li><code>| WizNote | Markdown| Latest |</code></li>
</ol>
<p>示例：</p>
<table>
<thead>
<tr>
<th>Typora</th>
<th>更新</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="10-粗体-斜体-删除线">10. 粗体、斜体、删除线</h3>
<p><strong>粗体</strong>：<code>**粗体**</code>，<em>斜体</em>：<code>*斜体*</code>，<s>删除线</s>：<code>~~删除线~~</code></p>
<h3 id="11-脚注">11. 脚注</h3>
<p>在需要添加脚注<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>的词后面加<code>[^1]</code>，并在文章结尾加入<code>[^1]: 注释内容</code></p>
<h3 id="12-高亮文本">12. 高亮文本</h3>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>脚注示例 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello World]]></title>
        <id>https://zzxll.github.io/post/hello-world/</id>
        <link href="https://zzxll.github.io/post/hello-world/">
        </link>
        <updated>2020-03-10T10:01:27.000Z</updated>
        <content type="html"><![CDATA[<p>你好，欢迎来到我的个人博客。本站点主要以个人分享为主，没有明确的主题。网站使用<a href="https://gridea.dev">Gridea</a>客户端进行搭建和管理，托管在GitHub Pages上。</p>
]]></content>
    </entry>
</feed>